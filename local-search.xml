<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JS数组的一些常用方法</title>
    <link href="/posts/b2537d69.html"/>
    <url>/posts/b2537d69.html</url>
    
    <content type="html"><![CDATA[<h2 id="JS数组的一些常用方法"><a href="#JS数组的一些常用方法" class="headerlink" title="JS数组的一些常用方法"></a>JS数组的一些常用方法</h2><p>这里介绍一些在写算法的过程中总结的常用的操作数组的方法：</p><p>新建一个数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peoples=[<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;sherlock&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;david&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">45</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">34</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">16</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;rita&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">103</span>&#125;<br>]<br></code></pre></div></td></tr></table></figure><p>以下的方法均基于此数组进行操作</p><h3 id="1-flier"><a href="#1-flier" class="headerlink" title="1.flier()"></a>1.flier()</h3><p>  Array.prototype.fliter()，返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peopleFliter=peoples.filter(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(peopleFliter)<br></code></pre></div></td></tr></table></figure><h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map()"></a>2.map()</h3><p>  对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。所有的 <code>Map</code> 对象实例都会继承 <code>Map.prototype</code></p><p>  map在实际使用常用于数组的去重等操作，由于js中没有Hashmap,但Hashmap其实是map的底层实现，通过map.has()和map.set()的配合可以实现去除数组重复值的效果。map这里只是简单的介绍下，后续还需更细致的去理解</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peopleNames=peoples.map(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> names.name<br>&#125;)<br><span class="hljs-built_in">console</span>.log(peopleNames)<br></code></pre></div></td></tr></table></figure><p>  如果放在浏览器中执行会看到以下结果,也就是上述所说的键值对的存储方式：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;sherlock&#x27;</span>, <span class="hljs-string">&#x27;david&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-string">&#x27;rita&#x27;</span>]<br><span class="hljs-number">0</span>: <span class="hljs-string">&quot;sherlock&quot;</span><br><span class="hljs-number">1</span>: <span class="hljs-string">&quot;david&quot;</span><br><span class="hljs-number">2</span>: <span class="hljs-string">&quot;tom&quot;</span><br><span class="hljs-number">3</span>: <span class="hljs-string">&quot;jerry&quot;</span><br><span class="hljs-number">4</span>: <span class="hljs-string">&quot;rita&quot;</span><br><span class="hljs-attr">length</span>: <span class="hljs-number">5</span><br>[[Prototype]]: <span class="hljs-built_in">Array</span>(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h4 id="2-1-放上一道LeetCode原题"><a href="#2-1-放上一道LeetCode原题" class="headerlink" title="2.1 放上一道LeetCode原题"></a>2.1 放上一道LeetCode原题</h4><p> <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a> ：</p><p>通过哈希表找到重复的值很好理解也很方便，将元素一个一个存入map，如果已经存了那就返回这个重复的值。</p><p>题解：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (set.has(item)) <span class="hljs-keyword">return</span> item<br>        set.add(item)<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="3-find"><a href="#3-find" class="headerlink" title="3.find()"></a>3.find()</h3><p>  Array.prototype.find()，返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。也就是说这个方法仅返回一个元素的值,如果是要找到索引的话，可以使用findIndex()方法</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> findPeople=peoples.find(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> names.name===<span class="hljs-string">&#x27;tom&#x27;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="4-forEach"><a href="#4-forEach" class="headerlink" title="4.forEach()"></a>4.forEach()</h3><p>  Array.prototype.forEach(),对数组的每个元素执行一次给定的函数。forEach()被调用时，不会改变原数组,改方法按升序为数组中含有效值的每一项执行一次 <code>callback</code> 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。这里只是打印出了数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">peoples.forEach(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(names.name)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="5-some"><a href="#5-some" class="headerlink" title="5.some()"></a>5.some()</h3><p>  Array.prototype.some(),改方法测试数组中是不是<strong>至少</strong>有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。空数组在任何情况下返回的都是false</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hasAge=peoples.some(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(hasAge)<br></code></pre></div></td></tr></table></figure><h3 id="6-every"><a href="#6-every" class="headerlink" title="6.every()"></a>6.every()</h3><p>  Array.prototype.every(),该方法测试一个数组内的所有元素是否<strong>都能</strong>通过某个指定函数的测试。它同样返回一个布尔值。可以和some()对照着看</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hasAges=peoples.every(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(hasAges)<br></code></pre></div></td></tr></table></figure><h3 id="7-reduce"><a href="#7-reduce" class="headerlink" title="7.reduce()"></a>7.reduce()</h3><p>Array.prototype.reduce(),该方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。返回值是函数累计处理的结果，这个特性就很适合用来计算数组的总和，<code>initialValue</code>作为第一次调用 <code>callback</code>函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。可以在MDN上了解更详细的传参介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> total=peoples.reduce(<span class="hljs-function">(<span class="hljs-params">currentTotal,names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age+currentTotal<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-built_in">console</span>.log(total)<br></code></pre></div></td></tr></table></figure><h4 id="7-1-放上一道LeetCode原题"><a href="#7-1-放上一道LeetCode原题" class="headerlink" title="7.1 放上一道LeetCode原题"></a>7.1 放上一道LeetCode原题</h4><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a>  ：</p><p>这道题的思路也简单，k次取反取最大值，首先想到的就是如果数组里有负数，那就需要优先对负数取反，如果没有负数，那就是只对数组中最小值取反，这样才能达到最大化的数组和。然后就是数组求和，写一个累加函数，自然而然就用上了reduce()，一气呵成。要想达到最优解还有优化的空间，这里只是我个人的题解思考。</p><p>题解:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> largestSumAfterKNegations = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ans,dp<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        ans=<span class="hljs-built_in">Math</span>.min(...nums)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==ans)&#123;<br>                dp=i<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>              nums[dp]+=-<span class="hljs-number">2</span>*nums[dp]  <br>            &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            nums[dp]+=-<span class="hljs-number">2</span>*nums[dp]<br>        &#125;<br>        k--<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.reduce(add,<span class="hljs-number">0</span>)<br>&#125;;<br><span class="hljs-comment">//用于求和</span><br><span class="hljs-keyword">var</span>  add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> a, b </span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="8-includes"><a href="#8-includes" class="headerlink" title="8.includes()"></a>8.includes()</h3><p>   Array.prototype.includes(),该方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。使用 <code>includes()</code>比较字符串和字符时是区分大小写的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> items=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">const</span> includesN=items.includes(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>以上是比较常用的操作数组的方法，还有更多后续介绍</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</a></p><p>[2]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p><p>[3]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find</a></p><p>[4]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></p><p>[5]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some</a></p><p>[6]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#%E8%AF%AD%E6%B3%95">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#%E8%AF%AD%E6%B3%95</a></p><p>[7]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a></p><p>[8]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#%E8%AF%AD%E6%B3%95">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#%E8%AF%AD%E6%B3%95</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之了解作用域</title>
    <link href="/posts/15242.html"/>
    <url>/posts/15242.html</url>
    
    <content type="html"><![CDATA[<h2 id="《You-Don’t-Know-JS》学习之了解作用域"><a href="#《You-Don’t-Know-JS》学习之了解作用域" class="headerlink" title="《You Don’t Know JS》学习之了解作用域"></a>《You Don’t Know JS》学习之了解作用域</h2><p>​    如果说你已经学会了如何在js里定义一个变量或常量，那你就已经接触到了作用域了，几乎所有的编程语言都定义一个变量后，你可以对这个变量进行输出、修改、赋值等操作。那么这里其实隐含了一个条件，为什么你能进行这些操作呢。其实，在定义完变量后，程序会存储变量中的值，之后便能对其进行访问或修改，而你可以把这一种能够访问赋值的能力当成一种状态，就好比你在小区能去小区楼下超市买东西，小区外面能进去吗？当然一定条件也可以。可如果说什么是军事基地呢？外部人员能够访问吗？显然不太可能。那么对于你定义的变量来说，有的可以很容易访问到，有的则需要一定的条件，才能获得这种访问的状态。</p><p>​    那么在什么时候访问？访问哪里，就需要一套规章制度来管理了，这样一种设计良好的规则就叫做作用域。作用域并不是js所特有的，但是在js中作用域有着一些特有的区别。</p><p>​    Js虽然是一门解释执行的语言，但也是一门编译语言，需要编译器对源代码进行编译。如果了解过js的发展的话，不难发现谷歌的V8引擎极其出色的编译性能也是推动js发展的一大动力。</p><p>​    传统的编译语言在源代码执行前有以下三个步骤，统称为编译：词法分析，语法分析，代码生成。了解这个有助于后面的理解。</p><h2 id="1-引擎的查询"><a href="#1-引擎的查询" class="headerlink" title="1.引擎的查询"></a>1.引擎的查询</h2><p>​    在js中有一个比较特别的词，叫做“执行上下文”。大部分情况js的代码编译发生在执行前的那段极短的时间，所以理解作用域是很重要的一个环节。至于引擎是如何工作的，显然超出了我目前的学习范围，这里只讲下书中说提到的“LHS查询”和“RHS查询”，这个其实是数学中的内容，LHS就是等式左边的意思，RHS同理。参考书中的例子，如果我在控制台输入一个变量b，引擎就会去找到b的值，如果没有找到，就会抛出RaferenceError的错误，这个时候是RHS查找。如果输入的是b=3，引擎就会在作用域中去找到b的值，并且为之赋值为3，如果没有就会向外层的作用域一层一层找过去，这里就是LHS查找。</p><p>简要的概括的话就是：LHS就是查找标志符以分配值；RHS则是查找需要使用的标志符。</p><p>那么这一道例题就很好理解了</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;<br><span class="hljs-keyword">var</span> b=a<br><span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">var</span> c=foo(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>这里一共有3个LHS查询和4个RHS查询</p><h3 id="1-1-作用域的嵌套"><a href="#1-1-作用域的嵌套" class="headerlink" title="1-1.作用域的嵌套"></a>1-1.作用域的嵌套</h3><p>​    如果对上述例子加以修改,将b的定义放在函数的外边，你会发现即使函数中b没有定义，依然会拿到值。这是因为作用域在按名称查找变量的这一套规则，通常是需要顾及到多个作用域的，但b在当前的函数作用域找不到的时候，回继续在外层的作用域去找，直到全局作用域。作用域的嵌套会产生一个神奇的东西，就是“闭包”，这里先不提。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;<br><span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">var</span> b=<span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> c=foo(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//4</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-异常"><a href="#1-2-异常" class="headerlink" title="1-2.异常"></a>1-2.异常</h3><p>​    当一个变量在所有的作用域中都找不到声明的时候，就会“报错”，之前提到了引擎是有LHS查询和RHS查询的，由于在ES5中引入了，“严格模式这个概念”，这里也会有所区别：</p><p>​    ①RHS查询如果找不到的话，就会抛出ReferenceError，如果找到了，但是对变量的值进来了不当的操作，比如对一个const变量赋值，就会抛出TypeError。</p><p>​    ②严格模式下的LHS查询失败的话也会抛出ReferenceError,但是在非严格模式下，也就是没有strict mode，LHS查询如果在全局也找不到改变量的话，就会自动创建一个改名称的变量返回给引擎</p><h2 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h2><p>​    在看到这已经对作用域有了大致的了解了，而文中提到的全局作用域、函数作用域，这之间又有什么样的关系，还有没有其他的作用域？就需要另起篇幅来讲解了。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup">https://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【第二期】vue3 工具函数源码阅读</title>
    <link href="/posts/46326.html"/>
    <url>/posts/46326.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>很感谢若川大佬组织的源码阅读</p><p>以下为原文：<a href="https://juejin.cn/post/6994976281053888519">https://juejin.cn/post/6994976281053888519</a></p></blockquote><p>​    源码阅读在我看来极具挑战，一方面是我没有系统的学过vue，甚至于官方文档也没有看过。所以在了解到这次的源码阅读活动跟框架关联不大的时候，对于框架源码阅读的压力也减轻了不少。而且跟着若川大佬的笔记入手，能够很有效的去分析问题。那么这里就开始第二期的源码阅读~</p><h2 id="1-阅读开源项目"><a href="#1-阅读开源项目" class="headerlink" title="1.阅读开源项目"></a>1.阅读开源项目</h2><p>​    首先给到项目的地址：<a href="https://github.com/vuejs/vue-next">https://github.com/vuejs/vue-next</a></p><p>​    在github上找项目的时候，首先就是找到带.md后缀的文档，打开来看。github上在每次新建仓库的时候都会有个选项是否需要添加ReadMe.md这个文件，这个就是用来写一些项目配置相关的东西。首先阅读readme也是一个初步的对项目的了解。由于大部分的开源项目都是英文的，为了节约时间便于阅读，可以借助DeepL翻译器来配合阅读。</p><blockquote><p>DeepL翻译器:<a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></p></blockquote><p>这里附上项目目录结构的部分内容：</p><ul><li>reactivity:reactivity系统。它可以作为一个与框架无关的包独立使用。</li></ul><ul><li>runtime-core:与平台无关的运行时核心。包括虚拟Dom渲染器、组件实现和JavaScript APIs的代码。针对特定平台的高阶运行时（即自定义渲染器）可以用这个包来创建。</li></ul><ul><li>runtime-dom: 以浏览器为目标的运行时。包括处理本地DOM API、属性、属性、事件处理程序等。</li></ul><ul><li>runtime-test:用于测试的轻量级运行时。可以在任何JavaScript环境中使用，因为它 “渲染 “了一棵纯JavaScript对象的树。该树可以用来保证正确的渲染输出。还提供了用于序列化树、触发事件和记录更新过程中执行的实际节点操作的实用程序。</li></ul><ul><li>server-renderer:用于服务器端渲染的包。</li></ul><ul><li>compiler-core:平台无关的编译器核心。包括编译器的可扩展基础和所有平台无关的插件。</li></ul><ul><li>compiler-dom:带有专门针对浏览器的附加插件的编译器。</li></ul><ul><li>compiler-ssr:编译器，产生为服务器端渲染而优化的渲染函数。</li></ul><ul><li><p>template-explorer:一个用于调试编译器输出的开发工具。你可以运行 nr dev template-explorer 并打开它的 index.html 来获得一个基于当前源代码的模板编译副本。</p><p>​    模板探索器的live版本也是可用的，它可以用来为编译器的错误提供副本。你也可以从部署日志中挑选特定提交的部署。</p></li><li><p>shared:多个软件包之间共享的内部实用程序（尤其是运行时和编译器软件包使用的环境无关的实用程序）。</p></li></ul><ul><li>vue:面向公众的 “完整构建”，包括运行时和编译器。</li></ul><h3 id="1-2-打包构建代码"><a href="#1-2-打包构建代码" class="headerlink" title="1-2.打包构建代码"></a>1-2.打包构建代码</h3><p>​    先将项目clone到本地，由于项目中使用的是TS，但我没学过TS，所以参考若川大佬的文章，打包构建将TS转为JS。这里首先需要安装Node.js,由于我之前安过，这里就不再重复步骤，可以通过node -v 判断自己是否已经安装了。先全局安装yarn，直接cd到项目文件夹去添加依赖。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm install --global yarn<br>yarn <br>yarn build<br></code></pre></div></td></tr></table></figure><p>build完之后可以在vue-next\packages\shared\dist 这个文件夹里看到.js的文件</p><h3 id="1-3-生成sourcemap调试源码"><a href="#1-3-生成sourcemap调试源码" class="headerlink" title="1-3.生成sourcemap调试源码"></a>1-3.生成sourcemap调试源码</h3><p>​    在package.json中添加上</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;dev:sourcemap&quot;</span>: <span class="hljs-string">&quot;node scripts/dev.js --sourcemap&quot;</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>然后</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">yarn</span> dev:sourcemap<br></code></pre></div></td></tr></table></figure><p>即可执行，生成sourcemap，控制台会给出生成的地址，这时候随便找个页面引入改文件，启动服务即可调试源码。</p><h2 id="2-调试源码"><a href="#2-调试源码" class="headerlink" title="2.调试源码"></a>2.调试源码</h2><p>​    在打好断点开始调试。首先看到的是下面这些</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">export const createApp = ((...args) =&gt; &#123;<br>  const app = ensureRenderer().createApp(...args)<br><br>  if (__DEV__) &#123;<br>    injectNativeTagCheck(app)<br>    injectCompilerOptionsCheck(app)<br>  &#125;<br>//省略<br>&#125;<br></code></pre></div></td></tr></table></figure><p>官方文档的解释是：每个 Vue 应用都是通过用 <code>createApp</code> 函数创建一个新的应用实例开始的</p><p>这里就是创建新的应用实例的第一步，然后看到if语句中有个 DEV ,于是去查了下，初步看来 DEV 是个bool类型的，从字面上理解起来有点像，springboot配置开发环境时用到的:application-dev和application-prod类似，查阅相关资料，DEV也确实就是在vue构建开发资源时，用于判断开发环境的一个常量，当处于开发环境时，DEV值为true,处于生产环境时，DEV值为false。</p><p>然后接下来会进入到ensureRenderer()函数的内部</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">function ensureRenderer() &#123;<br>  return (<br>    renderer ||<br>    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))<br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个地方可能是把创建完的对象返回过去了，这里不太懂，然后逐步调试，后面的API也看不懂了，就先不看。进入这一期的正题。</p><h2 id="3-工具函数"><a href="#3-工具函数" class="headerlink" title="3.工具函数"></a>3.工具函数</h2><p>​    这里的一些函数还是可以看懂的，我就挑几个我看的懂的记录下~</p><h3 id="onRE："><a href="#onRE：" class="headerlink" title="onRE："></a>onRE：</h3><p>这个是用到了正则去进行筛选。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> onRE = <span class="hljs-regexp">/^on[^a-z]/</span>;<br><span class="hljs-keyword">const</span> isOn = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> onRE.test(key);<br></code></pre></div></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove:"></a>remove:</h3><p>这里很容易看出来是对数组进行的操作，splice（），在i位置删除1个元素，可以在sublime里把这个函数放进去自己写个输入输出测试下。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> remove = <span class="hljs-function">(<span class="hljs-params">arr, el</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> i = arr.indexOf(el);<br>    <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">1</span>) &#123;<br>        arr.splice(i, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="hasOwnProperty："><a href="#hasOwnProperty：" class="headerlink" title="hasOwnProperty："></a>hasOwnProperty：</h3><p>这里在原型里常用到，用于判断是不是自己的</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;<br></code></pre></div></td></tr></table></figure><h3 id="is…"><a href="#is…" class="headerlink" title="is…:"></a>is…:</h3><p>这后面一大段代码就是用来判断类型的，不过不清楚为什么要加上$1,可能是为了防止重名？</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">const isArray$1 = Array.isArray;<br>const isMap$1 = (val) =&gt; toTypeString$1(val) === &#x27;[object Map]&#x27;;<br>const isSet$1 = (val) =&gt; toTypeString$1(val) === &#x27;[object Set]&#x27;;<br>const isDate$1 = (val) =&gt; val instanceof Date;<br>const isFunction$1 = (val) =&gt; typeof val === &#x27;function&#x27;;<br>const isString$1 = (val) =&gt; typeof val === &#x27;string&#x27;;<br>const isSymbol = (val) =&gt; typeof val === &#x27;symbol&#x27;;<br>const isObject$1 = (val) =&gt; val !== null &amp;&amp; typeof val === &#x27;object&#x27;;<br></code></pre></div></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>​    还有很多工具函数不能一一列举出来。看到现在，大部分的函数仔细分析还是能理解的，而且源码的命名在这里就能看出很规范，像动词+名词，在一定程度上能够理解这个函数是想要干什么。而且从开头clone项目到分析源码的这个过程，自己动手操作下来，阅读源码也不像是一件“高不可攀”的事情，可能刚开始有点吃力，但就算没有学过框架，只要能花些时间，也能够有很大的收获。</p>]]></content>
    
    
    <categories>
      
      <category>VUE</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之小序</title>
    <link href="/posts/38382.html"/>
    <url>/posts/38382.html</url>
    
    <content type="html"><![CDATA[<p>​    如果说对于一个语言，首先学习的是语法。那么对于js来说，大多数人都不是从学习”语法“开始的，而是直接使用js。在我一开始接触到这门语言，要如何理解js，就是一道迈不过去的坎、悬在头上的达摩克利斯之剑。</p><p>​    当我在没有系统的学习js之前，处在仅且会用的阶段，对于var、let、const的使用也是不求甚解，用来定义变量或常量，但要问起来又什么差别？不好意思，不知道，不了解。但就是这样在短时间内速成的js语法，如果不要求第二天立马弄个项目出来，这点东西也足够应付很多场景了，比如说写算法题。js中很重要的的闭包、原型、promise….，这些东西在写算法中并不是必须的，也就是抱着这样的侥幸心理，靠着几天速成的js基础，开始了算法之路。</p><p>​    不过几天的速成之路倒也不是什么都没学到，在fcc上靠着一道又一道的基础例题，边看MDN，边看一些技术文章。从只会var一个变量，靠着其他语言基础写点遍历的js小白，也算是略懂一些js的特性，容易弄混淆的this指向、闭包究竟是个什么东西？、手写一个promise、听起来极其高大上的函数柯里化。我就是在这样一边耳濡目染个个不知所以的名词，被前端学习群里的大佬发的面试题pua，一边穷尽“毕生所学”来刷算法，至终发觉，学海无涯，没有一个可靠的基础，所学就如大海之扁舟，无归无得。对我来说，扎实的前端基础学习迫在眉睫。</p><p>​    有人认为前端简单，确实，相比于其他语言，弱化类型就已经极大降低了js的使用学习成本，但js上手容易并不代表学起来容易，也更不代表前端学起来容易。前端已经不复当日“吴下阿蒙”，遍观js的发展历程，标准化ECMAScrip赫然登场，前端工程化，js框架三足鼎立更有typtscript、rust、webAssembly等等引领潮流。怎么看，前端都不仅仅是只需要个切图写界面的码农就能胜任的。</p><p>​    故而，学习的高度决定了能力的高度。今日以此为记，以学促成，以文促学，不忘学之本末。</p>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的查找排序算法</title>
    <link href="/posts/14180.html"/>
    <url>/posts/14180.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-查找算法"><a href="#1-查找算法" class="headerlink" title="1. 查找算法"></a>1. 查找算法</h3><h5 id="顺序查找："><a href="#顺序查找：" class="headerlink" title="顺序查找："></a>顺序查找：</h5><p>​    顺序查找又叫做线性查找，对于顺序表和链表都是适用的，它的基本思想就是从第一个元素开始，按顺序遍历待查找序列，直到找出给定目标或者查找失败。</p><h5 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h5><p>​    又叫折半查找，它要求列表必须是有序的。它的原理是每次都把待比较元素target和列表中间的元素mid进行比较，如果target小于mid，那么target再和位于mid前半部分的元素进行比较，并且再次选择中间元素进行比较，直到比较完所有元素为止。</p><blockquote><p>二分查找是一个理解简单但是细节十分考究的算法，对于比较区间的选择需要很全面才行</p></blockquote><h3 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2.排序算法"></a>2.排序算法</h3><h5 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h5><p>​    它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小（大）的元素会经由交换慢慢“浮”到数列的顶端。</p><h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><p>​    是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大） 元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><blockquote><p>参考资料：</p><p>[1]严蔚敏. 数据结构(C语言版)[J]. 计算机教育.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>浅谈</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见数据结构</title>
    <link href="/posts/326.html"/>
    <url>/posts/326.html</url>
    
    <content type="html"><![CDATA[<h2 id="常见数据结构："><a href="#常见数据结构：" class="headerlink" title="常见数据结构："></a>常见数据结构：</h2><p>​    数据结构是相互之间存在一种或多种特定关系的数据元素的集合。它的核心内涵是分解与抽象，并得到软件开发过程中需要用到的逻辑结构。</p><h4 id="数组（Array）："><a href="#数组（Array）：" class="headerlink" title="数组（Array）："></a>数组（Array）：</h4><p>​    将具有相同类型的若干数据组织在一起的集合，这是一种最基本而且也是一种最经常使用的数据结构</p><h4 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a>栈（Stack）：</h4><p>​    一种特殊的线性表，只能在一个表的固定端进行数据节点的插入和删除操作，栈正是一种按照后进先出（LIFO）的原则来存储数据的数据结构</p><h4 id="队列（Queue）："><a href="#队列（Queue）：" class="headerlink" title="队列（Queue）："></a>队列（Queue）：</h4><p>​    和栈类似，但不同的是，它是在一端执行入队操作，而在另一端进行出队操作</p><h4 id="链表（Linked-List）："><a href="#链表（Linked-List）：" class="headerlink" title="链表（Linked List）："></a>链表（Linked List）：</h4><p>​    它和数组一样，也是一组数据的集合，但和数组不一样的是， 它并不是一组连续的数据集合，而是通过指针连接在一起的。</p><h4 id="树（Tree）："><a href="#树（Tree）：" class="headerlink" title="树（Tree）："></a>树（Tree）：</h4><p>​    这是一种典型的非线性结构，之所以叫做“树”，是因为它的结构看起来就像一颗倒过来的树，它只有一个根结点，但可以有多个后继节点。</p><h4 id="堆（Heap）："><a href="#堆（Heap）：" class="headerlink" title="堆（Heap）："></a>堆（Heap）：</h4><p>​    它是一种特殊的树型结构，它的特点是根结点的值是所有节点中最大或者最小的，而且根结点的子节点也是一个堆结构。</p><h4 id="图（Graph）："><a href="#图（Graph）：" class="headerlink" title="图（Graph）："></a>图（Graph）：</h4><p>​    这也是一种非线性数据结构，在图结构中，数据节点称为顶点，顶点之间的连线称为边。</p><h4 id="散列表（Hash）："><a href="#散列表（Hash）：" class="headerlink" title="散列表（Hash）："></a>散列表（Hash）：</h4><p>​    其实就是哈希表，只不过一个是音译。这种数据结构来源于散列函数，它的思想是如果存在 x，那么就必然有一个唯一的存储位置 f(x)可以找到 x，这样通过数学函数就直接计算出 x 的存储位置而不用在进行比较、查找以后才知道。</p><p>ps:数据结构的内容远不是几句话能够说完的，尤其是树和图这一块，这里只是汇总常见的数据结构，做个梗概</p><blockquote><p>参考资料：</p><p>[1]严蔚敏. 数据结构(C语言版)[J]. 计算机教育.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络拓扑结构</title>
    <link href="/posts/56843.html"/>
    <url>/posts/56843.html</url>
    
    <content type="html"><![CDATA[<h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><h4 id="星型结构："><a href="#星型结构：" class="headerlink" title="星型结构："></a>星型结构：</h4><p>​    是指各计算机以星型方式连接成网。网络有中央节点，其他结点（工作站、服务器）都与中央节点直接相连，这种结构以中央结点为中心，因此又称为集中式网络。具有结构简单、便于管理、控制简单、网络延迟时间小、传输误差低等特点。但缺点也是明显的：可靠性较低、资源共享能力较差、线路利用率低。</p><blockquote><p>节点：指的是一个网络端口，如交换机、网关、路由器、防火墙等设备的端口</p></blockquote><h4 id="总线型结构："><a href="#总线型结构：" class="headerlink" title="总线型结构："></a>总线型结构：</h4><p>​    是指各工作站和服务器均挂在一条总线上，各工作站地位平等，无中心节点控制，它结构简单、可扩充性好、安装容易，但维护困难。</p><h4 id="环型结构："><a href="#环型结构：" class="headerlink" title="环型结构："></a>环型结构：</h4><p>​    由网络中若干结点通过通信链路首尾相连形成一个闭合的环，这种结构使公共传输电缆组成环状，数据在环路中沿着一个方向在各个节点间传输，信息从一个节点传到另一个节点。它实时性强、传输控制容易，但维护困难，可靠性不高。</p><blockquote><p>结点：指的是一台具体的网络设备，因为它们通常连接多个“节点”，故称之为“结点”</p><p>链路：是两个节点间的线路</p></blockquote><h4 id="网状结构："><a href="#网状结构：" class="headerlink" title="网状结构："></a>网状结构：</h4><p>​    它是指每台设备之间均有点到点的链路连接，这种连接不经济，只有每个站点都要频繁发送信息时才使用这种方法。它的安装也比较复杂，但系统可靠性高，容错能力强。有时也称为分布式结构。</p><blockquote><p>通路：是从发出信息的节点到接收信息的节点之间的一串节点和链路的组合</p></blockquote><h4 id="树型结构："><a href="#树型结构：" class="headerlink" title="树型结构："></a>树型结构：</h4><p>​    这是一种分级的集中控制式网络，与星型相比，它的通信线路总长度短，成本较低、节点易于扩充、寻找路径方便，但除了叶节点及其相连的线路外，任一节点或其相连的线路故障都会使系统受到影响。</p><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈语义化标签</title>
    <link href="/posts/439.html"/>
    <url>/posts/439.html</url>
    
    <content type="html"><![CDATA[<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><p>​        语义化标签是HTML5的新特性，赋予标签含义。给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，更利于开发者、程序和其他设备对于标签的理解。</p><p>​        语义化标签是应用于无障碍的一个重要的实践，在网页开发中，可访问性是指网页内容和用户界面可以被用户理解、浏览并与之交互。这里的用户包括有视觉障碍、听觉障碍或认知障碍的用户。所以语义化在软件、机器翻译等方面发挥着重要作用，同时搜索引擎也会通过语义化标签增强文章的SEO。</p><h3 id="1-常用的语义化标签"><a href="#1-常用的语义化标签" class="headerlink" title="1.常用的语义化标签"></a>1.常用的语义化标签</h3><p>​    </p><div class="table-container"><table><thead><tr><th>article</th><th>文章</th></tr></thead><tbody><tr><td>aside</td><td>侧边栏</td></tr><tr><td>main</td><td>主要内容</td></tr><tr><td>nav</td><td>导航栏</td></tr><tr><td>section</td><td>区域</td></tr><tr><td>header</td><td>页面的头部区域</td></tr><tr><td>footer</td><td>页面的尾部区域</td></tr><tr><td>mark</td><td>标记</td></tr><tr><td>ul</td><td>无序列表</td></tr><tr><td>form</td><td>表单</td></tr><tr><td>button</td><td>按钮</td></tr><tr><td>i</td><td>斜体</td></tr></tbody></table></div><h3 id="2-语义化标签的优点"><a href="#2-语义化标签的优点" class="headerlink" title="2.语义化标签的优点"></a>2.语义化标签的优点</h3><ul><li>语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是便于阅读、维护和理解</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO</li><li>用正确的标签做正确的事情</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈</tag>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈域名解析</title>
    <link href="/posts/39668.html"/>
    <url>/posts/39668.html</url>
    
    <content type="html"><![CDATA[<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>​        既然提到域名解析，那就先了解下什么是域名。访问一个网站，首先就是输入网址，浏览器再补充些网址的协议，如http/https，就成为了URL，URL全称是：Uniform Resource Location，翻译过来就是<strong>统一资源定位符</strong>。统一资源定位符包含的信息指出了文件的位置以及浏览器应该怎么处理它，而域名是Domain name。URL其实就是包含了域名在内的这样一串信息组成的地址。</p><p>​        任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。而域名系统（Domain name system，简称DNS）是互联网使用的命名系统，用于把人们使用的机器名字转化为IP地址，一台连接在互联网上的主机有IP地址，也有便于记忆的主机名字。IP地址可以来唯一标记每台主机在网络里的位置，域名系统则是将主机名字转换为IP地址，极大简化了记忆流程。域名解析其实就是将域名转换为 IP 地址的过程。</p><h3 id="1-域名规则"><a href="#1-域名规则" class="headerlink" title="1.域名规则"></a>1.域名规则</h3><p>​        英文域名只能由26个英文字母、0～9十个数字以及“-”连字符号混合而成，不支持使用空格及一些特殊字符，比如!?/\;:@#$%^~_=+,*&lt;&gt;等英文域名不区分大小写，也可以是纯英文和数字域名，对于中文域名而言，则必须含有中文字符域名级数是从右至左按照“.”分隔的部分确定的，有几个“.”就是几级，一般情况下， 域名最好不超过五级，例如 a.com 是一级域名，而 a.b.com则是二级域名每一级域名长度的限制是63个字符，域名总长度则不能超过 253 个字符常见的通用顶级域名为：.biz .com .edu .gov .info .int .mil .name .net .org 国家顶级域名参照 ISO 3166-1 中的双字母代码生成，例如中国大陆为.cn，中国香港 为.hk，中国台湾为.tw，美国为.us 通用域名可以组合国家域名，标明所在地区（只要域名管理机构允许），例如.gov.cn</p><h3 id="2-域名解析类型"><a href="#2-域名解析类型" class="headerlink" title="2. 域名解析类型"></a>2. 域名解析类型</h3><p>​        其实在自己购买域名后，需要一个域名解析的步骤，一般来说买来的域名会自己解析出几条记录，这个时候就需要自己重新配置，将自己网站的IP绑定到记录上去，从而实现关联。</p><h5 id="A-记录解析："><a href="#A-记录解析：" class="headerlink" title="A 记录解析："></a>A 记录解析：</h5><p>​            A 记录就是 Address 记录，是用来指定域名对应的 IP 地址，通常是将网站服务指向服务器地址。</p><h5 id="CNAME-记录解析："><a href="#CNAME-记录解析：" class="headerlink" title="CNAME 记录解析："></a>CNAME 记录解析：</h5><p>​            如果服务器的地址发生变动，光靠A记录就不行了。这时候就需要用到 CNAME，它又叫别名解析，也就是允许多个域名对应服务器的主机名，这样即使服务器的 IP 地址发生变更，也不用更改解析记录，域名解析会自动依据主机名更新IP地址。如果A记录解析和CNAME记录解析并存，那么A记录解析将优先生效。</p><h5 id="MX-记录解析："><a href="#MX-记录解析：" class="headerlink" title="MX 记录解析："></a>MX 记录解析：</h5><p>​            即邮件交换记录，这种记录解析用于将以域名为结尾的电子邮件指向对应的邮件服务器，例如用户所用的邮件以 xxx 为结尾，那么就需要在域名管理中添加该域名的 MX 记录来处理所有以@xxx为结尾的邮件。</p><h3 id="3-泛域名解析"><a href="#3-泛域名解析" class="headerlink" title="3.泛域名解析"></a>3.泛域名解析</h3><p>​        针对一个域名下所有未单独指定的主机名的域名解析就是泛域名解析。泛域名解析一般用在IP指向上，做一条泛域名解析就可以把一个域名下的所有主机名都解析到同一个IP地址上去。</p><p>ps:前端常见面试题有一道：描述浏览器从输入网址到页面展示的过程，这里就需要去深入了解其中的关键点，这里暂且不提</p><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域名</tag>
      
      <tag>浅谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的网络命令和端口</title>
    <link href="/posts/12653.html"/>
    <url>/posts/12653.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-常用网络命令"><a href="#1-常用网络命令" class="headerlink" title="1.常用网络命令"></a>1.常用网络命令</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping:"></a>ping:</h4><p>​        这是在实际应用中使用频率极高的一个命令，主要用于确定网络的连通性，如果要判断计算机是否能联网，执行的第一 条命令就是 ping 命令。它的格式是：ping 主机名/域名/IP 地址</p><p><img src="/img/190649.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="ipconfig-ifconfig："><a href="#ipconfig-ifconfig：" class="headerlink" title="ipconfig/ifconfig："></a>ipconfig/ifconfig：</h4><p>​        当使用不带任何参数选项 ipconfig/ifconfig 命令时，显示每 个已经配置了的接口的 IP 地址、子网掩码和缺省网关值。其中在 Windows 中使用的是 ipconfig，而在 Mac 或 Linux 系统中，使用的是 ifconfig</p><h4 id="netstat："><a href="#netstat：" class="headerlink" title="netstat："></a>netstat：</h4><p>​        能够显示活动的 TCP 连接、计算机侦听的端口、以太网统计信息、IP 路由表、IPv4 以及 IPv6 统计信息，通过它可以了解网络当前的状态</p><h3 id="2-常用网络端口"><a href="#2-常用网络端口" class="headerlink" title="2.常用网络端口"></a>2.常用网络端口</h3><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th>服务/协议</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:left">21</td><td>FTP</td><td>FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td style="text-align:left">22</td><td>SSH</td><td>SSH 连</td></tr><tr><td style="text-align:left">23</td><td>Telnet</td><td>远程登录服务</td></tr><tr><td style="text-align:left">25</td><td>SMTP</td><td>SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td style="text-align:left">80</td><td>HTTP</td><td>HTTP 协议默认端口号</td></tr><tr><td style="text-align:left">109</td><td>POP3</td><td>邮局协议端口号</td></tr><tr><td style="text-align:left">161</td><td>SNMP</td><td>网络管理协议端口号</td></tr><tr><td style="text-align:left">443</td><td>HTTPS</td><td>HTTPS 协议默认端口</td></tr><tr><td style="text-align:left">8080</td><td>www代理</td><td>一般的网站服务会开放此端口</td></tr></tbody></table></div><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈</tag>
      
      <tag>端口</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈计算机存储单位</title>
    <link href="/posts/45622.html"/>
    <url>/posts/45622.html</url>
    
    <content type="html"><![CDATA[<h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p>​        在计算机的内部，任何信息都被表示成二进制编码，二进制数据的每一位0或1是组成二进制信息的最小单位，称为一个“<strong>比特</strong>”(bit，或称作位元)，简称“位”，bit来源于binary digit，意思就是一个“二进制数字”，所以bit也是是计算机存储、运算、传输信息的最小单位。二进制信息的计量单位称为“<strong>字节</strong>”(Byte,或称作位组)，一个字节等于8个比特，通常b表示比特，B表示字节。</p><p>​        还有另外两个容易混淆的是“字”（word）和“字长”，<strong>字长</strong>等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，我们常说的电脑是64位或32位，就是指字长。而<strong>字</strong>则是用于度量各种数据类型的宽度，不同的计算机字的长度和组成不完全相同，一台机器在提供数据类型的时候，就需要给出一个基本的字的宽度。</p><h3 id="1-单位定义"><a href="#1-单位定义" class="headerlink" title="1.单位定义"></a>1.单位定义</h3><p>​        存储单位：存储在计算机硬盘或内存中的信息容量标准，最小计量单位是“位”（bit， 比特），一个比特位表示一个二进制的 0 或 1 在计算机中所占用的存储空间</p><p>​        传输单位：在计算机网络中称为带宽，宽带传输速率的单位为bit/s,也可以写为bps，bps 是 bit per second 的缩写，表示每秒钟传输多少比特位信息，这里的b不是指Byte字节，而是bit位。例如：带宽的单位是 100MB/S，这里其实指的是每秒传输 100 兆 位，而不是 100 兆字节数据，因此将位数需要除以 8 换算成字节数，也就是每秒传输 12.5 兆字节，即 100MBit/S = 12.5MByte/</p><h3 id="2-单位换算"><a href="#2-单位换算" class="headerlink" title="2.单位换算"></a>2.单位换算</h3><p>​        1 字节（Byte）= 8 位（bit） </p><p>​        1KB（Kilo Byte）= 1024B（Byte字节）</p><p>​        1MB（Mega Byte）= 1024KB </p><p>​        1GB（Giga Byte）= 1024MB </p><p>​        1TB（Tera Byte）= 1024G</p><blockquote><p>参考资料：</p><p>[1]:袁春风. 计算机系统基础[M]. 机械工业出版社, 2014.</p><p>[2]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈</tag>
      
      <tag>信息处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode上的那些计数排序</title>
    <link href="/posts/62795.html"/>
    <url>/posts/62795.html</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>​        时间复杂度：O(n+k)，即线性时间，k为给定数据中的最大值（k为整数范围），而其他的排序方法则最好的情况才是O(nlgn)。这是计数排序用空间换取时间的便利，也是计数排序只在特定情况才能使用的缺陷。</p><p>​        空间复杂度：总的空间复杂度为O(n+k)，因为用到了另一个数组O(k)用于存储。</p><blockquote><p>看完此文可以在力扣上轻松解决以下问题：</p><p><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></p><p><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></p><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p><a href="https://leetcode-cn.com/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></p></blockquote><p>​        偶然间在力扣上看到一排序的题，便点了进去。<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>题目意思很简单将数组升序排列，如果是为了快速解题的话，直接出结果，用sort()方法一步就行，但看了看难度，怎么是个中等题。于是在题库的归类里赫然看到“<strong>计数排序</strong>”这四个大字。那便来学习下计数排序</p><p>​        计数排序英文名：Counting Sort，顾名思义。注意这里有个中文读音很像的<strong>“基数排序”</strong>，两者是有所不同的，基数排序英文是：Radix sort，radix英文中意思是基数，而基数在数学中是集合论的一个概念，两个能够建立元素间一一对应的集合称为互相对等集合，基数排序这里暂且不提。</p><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>​        首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。有另一种不借助额外的存储空间的，只使用计数数组作为辅助存储，但是这种修改后的并不稳定。</p><hr><p>​    In computer science, <strong>counting sort</strong> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm.                                                                     ——from wikipedia</p><hr><h3 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h3><p>​        通过数组实现，将原数组中整数的值，作为索引，在另一个数组上对应的索引累加。也就是说，不通过比较，而是索引下标确定值的位置。然后遍历目标数组，依次输出就是排序后的结果。一般用于比较小的正整数，太大会造成目标数组空间的浪费。keys 可以理解为 index的键， 既然将值作为索引，那负数是不支持的。但是为了对负数也能够排序，在初始化数组空间的时候，可以通过加上一个固定的值（max-min+1），来实现对负数的取正。 </p><h3 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h3><p>​        下面以力扣的912.排序数组为例：</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">Input:<br><span class="hljs-string">[1, 3, 2, 8, 5, 1, 5, 1, 2, 7]</span><br>Output:<br><span class="hljs-string">[1, 1, 1, 2, 2, 3, 5, 5, 7, 8]</span><br></code></pre></div></td></tr></table></figure><p>首先需要初始化三个变量，max用于计算数据最大值，dp初始化为空数组用于输出，ans用于构建计数数组</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​        这个时候就算是写完了，但是拿去测试的时候你会发现报错了。为什么呢？题目中给出的数据范围是：[-50000,50000]，这时候你看完了前面的内容可能会想了，计数排序无法适用于负数的原因就是将值作为索引，那么索引一定不能是负的。出错的原因就在这！前面也提到了有解决的办法，其实很简单。只需要稍加修改.</p><p>​        添加变量min用于计算数据中的最小值，在数组初始化的时候，空间大小初始化为max-min+1，也就是间接的将负数对应的索引”取正“。这里在后面的几个循环中需要注意循环截止的条件！</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> min=<span class="hljs-built_in">Math</span>.min(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max-min+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d-min]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max-min+<span class="hljs-number">1</span>; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k+min);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​        写到此，计数排序的代码已经完成了，有兴趣的可以试试原地排序。</p><p>​        特别需要提到的，在翻阅了很多资料中，并没有给出过Js的计数排序模板，Js的数组也不是实际意义上的数组，而是对象，还有很多方法可以用来优化以上代码，但思路始终是这个思路，这里暂且不提。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p>[2]:<a href="https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/">https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/</a></p><p>[3]:<a href="https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c">https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
