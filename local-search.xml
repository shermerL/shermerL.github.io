<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈语义化标签</title>
    <link href="/2021/11/17/%E6%B5%85%E8%B0%88%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/11/17/%E6%B5%85%E8%B0%88%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><p>​        语义化标签是HTML5的新特性，赋予标签含义。给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，更利于开发者、程序和其他设备对于标签的理解。</p><p>​        语义化标签是应用于无障碍的一个重要的实践，在网页开发中，可访问性是指网页内容和用户界面可以被用户理解、浏览并与之交互。这里的用户包括有视觉障碍、听觉障碍或认知障碍的用户。所以语义化在软件、机器翻译等方面发挥着重要作用，同时搜索引擎也会通过语义化标签增强文章的SEO。</p><h3 id="1-常用的语义化标签"><a href="#1-常用的语义化标签" class="headerlink" title="1.常用的语义化标签"></a>1.常用的语义化标签</h3><p>​    </p><div class="table-container"><table><thead><tr><th>article</th><th>文章</th></tr></thead><tbody><tr><td>aside</td><td>侧边栏</td></tr><tr><td>main</td><td>主要内容</td></tr><tr><td>nav</td><td>导航栏</td></tr><tr><td>section</td><td>区域</td></tr><tr><td>header</td><td>页面的头部区域</td></tr><tr><td>footer</td><td>页面的尾部区域</td></tr><tr><td>mark</td><td>标记</td></tr><tr><td>ul</td><td>无序列表</td></tr><tr><td>form</td><td>表单</td></tr><tr><td>button</td><td>按钮</td></tr><tr><td>i</td><td>斜体</td></tr></tbody></table></div><h3 id="2-语义化标签的优点"><a href="#2-语义化标签的优点" class="headerlink" title="2.语义化标签的优点"></a>2.语义化标签的优点</h3><ul><li>语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是便于阅读、维护和理解</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO</li><li>用正确的标签做正确的事情</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈域名解析</title>
    <link href="/2021/11/17/%E6%B5%85%E8%B0%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/11/17/%E6%B5%85%E8%B0%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>​        既然提到域名解析，那就先了解下什么是域名。访问一个网站，首先就是输入网址，浏览器再补充些网址的协议，如http/https，就成为了URL，URL全称是：Uniform Resource Location，翻译过来就是<strong>统一资源定位符</strong>。统一资源定位符包含的信息指出了文件的位置以及浏览器应该怎么处理它，而域名是Domain name。URL其实就是包含了域名在内的这样一串信息组成的地址。</p><p>​        任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。而域名系统（Domain name system，简称DNS）是互联网使用的命名系统，用于把人们使用的机器名字转化为IP地址，一台连接在互联网上的主机有IP地址，也有便于记忆的主机名字。IP地址可以来唯一标记每台主机在网络里的位置，域名系统则是将主机名字转换为IP地址，极大简化了记忆流程。域名解析其实就是将域名转换为 IP 地址的过程。</p><h3 id="1-域名规则"><a href="#1-域名规则" class="headerlink" title="1.域名规则"></a>1.域名规则</h3><p>​        英文域名只能由26个英文字母、0～9十个数字以及“-”连字符号混合而成，不支持使用空格及一些特殊字符，比如!?/\;:@#$%^~_=+,*&lt;&gt;等英文域名不区分大小写，也可以是纯英文和数字域名，对于中文域名而言，则必须含有中文字符域名级数是从右至左按照“.”分隔的部分确定的，有几个“.”就是几级，一般情况下， 域名最好不超过五级，例如 a.com 是一级域名，而 a.b.com则是二级域名每一级域名长度的限制是63个字符，域名总长度则不能超过 253 个字符常见的通用顶级域名为：.biz .com .edu .gov .info .int .mil .name .net .org 国家顶级域名参照 ISO 3166-1 中的双字母代码生成，例如中国大陆为.cn，中国香港 为.hk，中国台湾为.tw，美国为.us 通用域名可以组合国家域名，标明所在地区（只要域名管理机构允许），例如.gov.cn</p><h3 id="2-域名解析类型"><a href="#2-域名解析类型" class="headerlink" title="2. 域名解析类型"></a>2. 域名解析类型</h3><p>​        其实在自己购买域名后，需要一个域名解析的步骤，一般来说买来的域名会自己解析出几条记录，这个时候就需要自己重新配置，将自己网站的IP绑定到记录上去，从而实现关联。</p><h5 id="A-记录解析："><a href="#A-记录解析：" class="headerlink" title="A 记录解析："></a>A 记录解析：</h5><p>​            A 记录就是 Address 记录，是用来指定域名对应的 IP 地址，通常是将网站服务指向服务器地址。</p><h5 id="CNAME-记录解析："><a href="#CNAME-记录解析：" class="headerlink" title="CNAME 记录解析："></a>CNAME 记录解析：</h5><p>​            如果服务器的地址发生变动，光靠A记录就不行了。这时候就需要用到 CNAME，它又叫别名解析，也就是允许多个域名对应服务器的主机名，这样即使服务器的 IP 地址发生变更，也不用更改解析记录，域名解析会自动依据主机名更新IP地址。如果A记录解析和CNAME记录解析并存，那么A记录解析将优先生效。</p><h5 id="MX-记录解析："><a href="#MX-记录解析：" class="headerlink" title="MX 记录解析："></a>MX 记录解析：</h5><p>​            即邮件交换记录，这种记录解析用于将以域名为结尾的电子邮件指向对应的邮件服务器，例如用户所用的邮件以 xxx 为结尾，那么就需要在域名管理中添加该域名的 MX 记录来处理所有以@xxx为结尾的邮件。</p><h3 id="3-泛域名解析"><a href="#3-泛域名解析" class="headerlink" title="3.泛域名解析"></a>3.泛域名解析</h3><p>​        针对一个域名下所有未单独指定的主机名的域名解析就是泛域名解析。泛域名解析一般用在IP指向上，做一条泛域名解析就可以把一个域名下的所有主机名都解析到同一个IP地址上去。</p><p>ps:前端常见面试题有一道：描述浏览器从输入网址到页面展示的过程，这里就需要去深入了解其中的关键点，这里暂且不提</p><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的网络命令和端口</title>
    <link href="/2021/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E5%92%8C%E7%AB%AF%E5%8F%A3/"/>
    <url>/2021/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E5%92%8C%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-常用网络命令"><a href="#1-常用网络命令" class="headerlink" title="1.常用网络命令"></a>1.常用网络命令</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping:"></a>ping:</h4><p>​        这是在实际应用中使用频率极高的一个命令，主要用于确定网络的连通性，如果要判断计算机是否能联网，执行的第一 条命令就是 ping 命令。它的格式是：ping 主机名/域名/IP 地址</p><p><img src="/img/190649.jpg" alt=""></p><h4 id="ipconfig-ifconfig："><a href="#ipconfig-ifconfig：" class="headerlink" title="ipconfig/ifconfig："></a>ipconfig/ifconfig：</h4><p>​        当使用不带任何参数选项 ipconfig/ifconfig 命令时，显示每 个已经配置了的接口的 IP 地址、子网掩码和缺省网关值。其中在 Windows 中使用的是 ipconfig，而在 Mac 或 Linux 系统中，使用的是 ifconfig</p><h4 id="netstat："><a href="#netstat：" class="headerlink" title="netstat："></a>netstat：</h4><p>​        能够显示活动的 TCP 连接、计算机侦听的端口、以太网统计信息、IP 路由表、IPv4 以及 IPv6 统计信息，通过它可以了解网络当前的状态</p><h3 id="2-常用网络端口"><a href="#2-常用网络端口" class="headerlink" title="2.常用网络端口"></a>2.常用网络端口</h3><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th>服务/协议</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:left">21</td><td>FTP</td><td>FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td style="text-align:left">22</td><td>SSH</td><td>SSH 连</td></tr><tr><td style="text-align:left">23</td><td>Telnet</td><td>远程登录服务</td></tr><tr><td style="text-align:left">25</td><td>SMTP</td><td>SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td style="text-align:left">80</td><td>HTTP</td><td>HTTP 协议默认端口号</td></tr><tr><td style="text-align:left">109</td><td>POP3</td><td>邮局协议端口号</td></tr><tr><td style="text-align:left">161</td><td>SNMP</td><td>网络管理协议端口号</td></tr><tr><td style="text-align:left">443</td><td>HTTPS</td><td>HTTPS 协议默认端口</td></tr><tr><td style="text-align:left">8080</td><td>www代理</td><td>一般的网站服务会开放此端口</td></tr></tbody></table></div><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>端口</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈计算机存储单位</title>
    <link href="/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/"/>
    <url>/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p>​        在计算机的内部，任何信息都被表示成二进制编码，二进制数据的每一位0或1是组成二进制信息的最小单位，称为一个“<strong>比特</strong>”(bit，或称作位元)，简称“位”，bit来源于binary digit，意思就是一个“二进制数字”，所以bit也是是计算机存储、运算、传输信息的最小单位。二进制信息的计量单位称为“<strong>字节</strong>”(Byte,或称作位组)，一个字节等于8个比特，通常b表示比特，B表示字节。</p><p>​        还有另外两个容易混淆的是“字”（word）和“字长”，<strong>字长</strong>等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，我们常说的电脑是64位或32位，就是指字长。而<strong>字</strong>则是用于度量各种数据类型的宽度，不同的计算机字的长度和组成不完全相同，一台机器在提供数据类型的时候，就需要给出一个基本的字的宽度。</p><h3 id="1-单位定义"><a href="#1-单位定义" class="headerlink" title="1.单位定义"></a>1.单位定义</h3><p>​        存储单位：存储在计算机硬盘或内存中的信息容量标准，最小计量单位是“位”（bit， 比特），一个比特位表示一个二进制的 0 或 1 在计算机中所占用的存储空间</p><p>​        传输单位：在计算机网络中称为带宽，宽带传输速率的单位为bit/s,也可以写为bps，bps 是 bit per second 的缩写，表示每秒钟传输多少比特位信息，这里的b不是指Byte字节，而是bit位。例如：带宽的单位是 100MB/S，这里其实指的是每秒传输 100 兆 位，而不是 100 兆字节数据，因此将位数需要除以 8 换算成字节数，也就是每秒传输 12.5 兆字节，即 100MBit/S = 12.5MByte/</p><h3 id="2-单位换算"><a href="#2-单位换算" class="headerlink" title="2.单位换算"></a>2.单位换算</h3><p>​        1 字节（Byte）= 8 位（bit） </p><p>​        1KB（Kilo Byte）= 1024B（Byte字节）</p><p>​        1MB（Mega Byte）= 1024KB </p><p>​        1GB（Giga Byte）= 1024MB </p><p>​        1TB（Tera Byte）= 1024G</p><blockquote><p>参考资料：</p><p>[1]:袁春风. 计算机系统基础[M]. 机械工业出版社, 2014.</p><p>[2]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode上的那些计数排序</title>
    <link href="/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>​        时间复杂度：O(n+k)，即线性时间，k为给定数据中的最大值（k为整数范围），而其他的排序方法则最好的情况才是O(nlgn)。这是计数排序用空间换取时间的便利，也是计数排序只在特定情况才能使用的缺陷。</p><p>​        空间复杂度：总的空间复杂度为O(n+k)，因为用到了另一个数组O(k)用于存储。</p><blockquote><p>看完此文可以在力扣上轻松解决以下问题：</p><p><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></p><p><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></p><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p><a href="https://leetcode-cn.com/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></p></blockquote><p>​        偶然间在力扣上看到一排序的题，便点了进去。<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>题目意思很简单将数组升序排列，如果是为了快速解题的话，直接出结果，用sort()方法一步就行，但看了看难度，怎么是个中等题。于是在题库的归类里赫然看到“<strong>计数排序</strong>”这四个大字。那便来学习下计数排序</p><p>​        计数排序英文名：Counting Sort，顾名思义。注意这里有个中文读音很像的<strong>“基数排序”</strong>，两者是有所不同的，基数排序英文是：Radix sort，radix英文中意思是基数，而基数在数学中是集合论的一个概念，两个能够建立元素间一一对应的集合称为互相对等集合，基数排序这里暂且不提。</p><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>​        首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。有另一种不借助额外的存储空间的，只使用计数数组作为辅助存储，但是这种修改后的并不稳定。</p><hr><p>​    In computer science, <strong>counting sort</strong> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm.                                                                     ——from wikipedia</p><hr><h3 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h3><p>​        通过数组实现，将原数组中整数的值，作为索引，在另一个数组上对应的索引累加。也就是说，不通过比较，而是索引下标确定值的位置。然后遍历目标数组，依次输出就是排序后的结果。一般用于比较小的正整数，太大会造成目标数组空间的浪费。keys 可以理解为 index的键， 既然将值作为索引，那负数是不支持的。但是为了对负数也能够排序，在初始化数组空间的时候，可以通过加上一个固定的值（max-min+1），来实现对负数的取正。 </p><h3 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h3><p>​        下面以力扣的912.排序数组为例：</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">Input:<br><span class="hljs-string">[1, 3, 2, 8, 5, 1, 5, 1, 2, 7]</span><br>Output:<br><span class="hljs-string">[1, 1, 1, 2, 2, 3, 5, 5, 7, 8]</span><br></code></pre></td></tr></table></figure><p>首先需要初始化三个变量，max用于计算数据最大值，dp初始化为空数组用于输出，ans用于构建计数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        这个时候就算是写完了，但是拿去测试的时候你会发现报错了。为什么呢？题目中给出的数据范围是：[-50000,50000]，这时候你看完了前面的内容可能会想了，计数排序无法适用于负数的原因就是将值作为索引，那么索引一定不能是负的。出错的原因就在这！前面也提到了有解决的办法，其实很简单。只需要稍加修改.</p><p>​        添加变量min用于计算数据中的最小值，在数组初始化的时候，空间大小初始化为max-min+1，也就是间接的将负数对应的索引”取正“。这里在后面的几个循环中需要注意循环截止的条件！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> min=<span class="hljs-built_in">Math</span>.min(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max-min+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d-min]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max-min+<span class="hljs-number">1</span>; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k+min);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        写到此，计数排序的代码已经完成了，有兴趣的可以试试原地排序。</p><p>​        特别需要提到的，在翻阅了很多资料中，并没有给出过Js的计数排序模板，Js的数组也不是实际意义上的数组，而是对象，还有很多方法可以用来优化以上代码，但思路始终是这个思路，这里暂且不提。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p>[2]:<a href="https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/">https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/</a></p><p>[3]:<a href="https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c">https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
