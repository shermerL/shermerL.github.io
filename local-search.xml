<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之阶段小结</title>
    <link href="/posts/d152b5b1.html"/>
    <url>/posts/d152b5b1.html</url>
    
    <content type="html"><![CDATA[<ul><li><p>[x] 《You Don’t Know JS》 上册</p></li><li><p>[x] 《You Don’t Know JS》 中册</p></li><li><p>[ ] 《You Don’t Know JS》 下册</p><p>从上次写下小序的时候算起，也已过了一个月，在这段时间内，我完成了上册与中册的阅读，下册就阅读的难度来说，在这两天也能够看完。</p><p>上册在基础概念和JS特性上进行了详细的介绍，从作用域到闭包，从this到对象，从原型到类，还有介绍了行为委托在实际中的使用。这册的主要内容和难点其实就是JS这些特性。</p><p>当你深入了解了JS的词法作用域和引擎在执行的过程中发挥了怎样的作用，对于闭包的理解也就很接近了，而闭包则是JS当中无处不在的明显的事实，其后引入了模块的概念，这一段在书中讲解较少，需要配合其他资料详细了解。而后对于this的绑定，要通过分析调用栈来理解，this的绑定对象究竟是什么，对象与对象之间有着什么样的关系，最终都会探寻到原型链这一概念，本质其实就是对象之间的关联关系。至于通过类这一语法糖和对象关联风格在行为委托这一实际应用上如何区别、理解。就是这一册最后的难点了。</p><p>如果说上册所讲的内容是JS的灵魂的话，那么中册所介绍的异步编程就是JS的骨架了，一个结实的骨架正是这个语言能够持续发展的极大助力，在第二册中，作者花了接近一半的篇幅来介绍Promise这一范式，相应的我在看这一册书的时候，所花的时间是上册的五倍之多，前一半篇幅在介绍JS的类型与语法，由于JS是弱类型的语言，而不可避免的，JS代码在执行过程中，会发生类型转换，如果是强制的类型转换在代码层面能够很容易看出，而弱类型转换则需要仔细辨别，至于语法层面，运算符的使用也是值得注意的一点，“=”、“==”、“===”的区别，同样夹杂着类型转换的情况。异步这块，重点讲述的ES6的新特性之一Promise。回调是JS中异步的基本单元，但是回调这种实现异步的方式难以理解，而且产生的控制反转会引起麻烦的信任问题。回调解决了程序异步和管理的两大缺陷，一个是缺乏顺序性，再一个就是可信任性，但是控制反转的问题使得信任性很脆弱，而将这种控制反转再次的反转回来的范式就叫做Promise。之后介绍了一种能够将异步过程同步理解的另一个ES6特性——生成器。生成器的yield能够神奇的暂停函数的执行，，类似的一个ajax的消息接收，看似整个流程是同步的，但是实则依靠着yield实现了一个异步的过程。</p><p>Promise和生成器这一块是我花的时间最多的地方，来回揣摩毕竟也只是纸上谈兵，在这里想要真正的理解尚需自己的不断实践。中册的最后提到了对于JS中性能测试的思路和对于调优的理解。</p><p>下册中，主要讲的是ES6中的新内容，毕竟JavaScript的主要内容包括ECMAScript、DOM和BOM，ECMAScript的内容更新则是JS不可或缺的肉，这是在实际使用阶段不断的优化内容的体现。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何登录Spotify</title>
    <link href="/posts/c2d13248.html"/>
    <url>/posts/c2d13248.html</url>
    
    <content type="html"><![CDATA[<h2 id="如何登录Spotify"><a href="#如何登录Spotify" class="headerlink" title="如何登录Spotify"></a>如何登录Spotify</h2><blockquote><p>鉴于目前网上spotify的相关教程有些细节不一致，现根据个人经验，总结换区等相关操作。</p></blockquote><h2 id="1-各大流媒体音乐平台"><a href="#1-各大流媒体音乐平台" class="headerlink" title="1.各大流媒体音乐平台"></a>1.各大流媒体音乐平台</h2><p>先介绍下目前的几大流媒体音乐平台：apple music、spotify、tidal、QQ音乐、网易云音乐。未列出的不代表没人用，只是这里暂不考虑。</p><p>对于国内的音乐平台，就版权来说，QQ音乐当属第一，网易云音乐就不说了，自从开辟社交元素之后属于是走偏了路，界面功能越来越臃肿，可能是得益于版权较少的原因？一些音乐创作人的入驻，也能够带来些新鲜的血液，就比如我常听的一些city pop类型的歌，在其他平台上始终是找不到。音质方面，国内平台都是半斤八两，除开是音乐发烧友，一般听歌基本没问题。界面操作方面，QQ音乐的PC端用着蛮舒服；然后网易云这块，手机端就那样，pc界面有个大更新，增强了交互的动效感，可能个人审美不同吧，自从这么改动之后，我就没用过pc端的网易云了，投奔到了网易云HD。改的很好啊网易云，下次不要这样改了。付费方面，一个月十多块？那为什么不用apple Music？国区学生认证，一个月5块钱不香吗？诸多因素导致了我转移了听歌重地，投向了国外流媒体平台。</p><h2 id="2-Apple-music"><a href="#2-Apple-music" class="headerlink" title="2.Apple music"></a>2.Apple music</h2><p>国区和外区的付费手段不一样，价格也不一样，曲库也不一样，根据个人情况选择就行了，这里不做介绍。</p><h2 id="3-Tidal"><a href="#3-Tidal" class="headerlink" title="3.Tidal"></a>3.Tidal</h2><p>这个是一般听众不会接触的平台，以CD级的Hi-Fi音质作为背书，付费订阅，价格劝退，没有用过，不做介绍。</p><h2 id="4-Spotify"><a href="#4-Spotify" class="headerlink" title="4.Spotify"></a>4.Spotify</h2><p>之所以会选择Spotify，这得从国内平台提供会员制开始说起，很多版权的歌只能在这个平台开了会员才能听，另一些歌在另一个平台要开另外的会员。？？？这着实用起来有一种撕裂感，而且很影响体验，那有没有不用来回跳平台，还不用充会员的平台呢？这就不得不说Spotify了！提供免费订阅+国内平台无法比拟的曲库=比较完美的听歌体验。但鱼和熊掌不可兼得，换来的代价就是，不付费就没有高音质，这个可以理解，都免费了还要什么自行车。另一个代价就是没有歌词，但用习惯了，也可有可无了，而且spotify也在测试歌词功能？港区的部分歌曲可以看到提供了歌词，这在早些年是要借助其他歌词软件才能实现的。还有两个比较致命的缺点就是，非会员在某些设备只支持随机播放+音频广告（虽然实际用下来没太感觉到广告的存在，但有广告就是 有广告🤔）。当然这些除了歌词都是可以靠充钱解决的😄</p><h3 id="4-1-多平台Spotify使用体验"><a href="#4-1-多平台Spotify使用体验" class="headerlink" title="4-1.多平台Spotify使用体验"></a>4-1.多平台Spotify使用体验</h3><ul><li>手机端：可通过AppStore或者Google store（需要有谷歌套件的支持才能用）下载，仅支持随机播放，不支持歌单选歌</li><li>电脑端：体验最好，支持歌单选歌，有些歌有可能有歌词</li><li>平板端：有的平板由于系统原因？应该下不了Spotify。体验和电脑端一样</li></ul><h3 id="4-2-如何上手使用Spotify"><a href="#4-2-如何上手使用Spotify" class="headerlink" title="4-2.如何上手使用Spotify"></a>4-2.如何上手使用Spotify</h3><p><strong>由于Spotify在国区不提供服务</strong>，首先你需要有个非国区账号，可以借助VPN技术实现非国区的注册，怎么借助VPN技术，如何使用VPN技术，不在本文的讨论范围内，请理性使用。由于没有国区的服务，因此就不建议充钱，一个原因是，比较贵，对比国区Apple music 5块钱；再一个就是，充钱很麻烦！而且之后换区也比较麻烦！免费订阅的可以随意换区！</p><h4 id="4-2-1-注册"><a href="#4-2-1-注册" class="headerlink" title="4-2-1.注册"></a>4-2-1.注册</h4><p>注册步骤，通过VPN技术，选择你想注册的区所属的国家，登录Spotify官网，进行注册，建议使用非QQ邮箱的其他邮箱进行注册。如果这个时候，Spotify官网提示在该国家不提供服务。这就说明，你使用的VPN没有开启全局代理，可以在VPN的设置里看看，打开全局代理。Spotify虽然没有国区服务，但是官网是不需要翻墙也能够访问的，这时候你使用的VPN以为你访问的网站不需要代理，就会通过国内的网络进行访问。这个点也是后续在换区经常出现的情况。</p><p>填上相应的信息后，邮箱验证，即可登录使用，这时候你可以在个人中心的资料里找到你当前账号所属的区，后续改区也是在这里改。</p><ul><li>VPN开全局，区域随便选，后续可以改，用非QQ邮箱的其他邮箱注册</li></ul><h4 id="4-2-2-换区"><a href="#4-2-2-换区" class="headerlink" title="4-2-2.换区"></a>4-2-2.换区</h4><p>登录之后，会提示你只有14天的使用时间，除非你去到其他国家。这时候14天期限到了，就又需要借助VPN技术了，这次换另外一个不同的地区，VPN开启全局之后，登录点开个人资料，编辑个人资料的地区的时候，会发现有个下拉栏，会出现你当前要改的区，直接选择然后确认编辑就行了。这个时候VPN不要关，同样要去重新登录下。</p><p>如果发现登录仍旧提醒你在当前地区不可用，这时候，需要检查是否VPN开的全局，然后就是在登录的下方，Spotify 有个代理模式，选择跟随系统设置。这时候可以成功登录。</p><h4 id="4-2-3-使用"><a href="#4-2-3-使用" class="headerlink" title="4-2-3.使用"></a>4-2-3.使用</h4><p>一旦登录成功，就不需要VPN也可以继续听歌</p><p>使用Spotify的最大麻烦点就是在于换区和非会员的设备功能缺陷上。所以根据个人情况选择平台，避免折腾。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spotify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数组的一些常用方法</title>
    <link href="/posts/b2537d69.html"/>
    <url>/posts/b2537d69.html</url>
    
    <content type="html"><![CDATA[<h2 id="JS数组的一些常用方法"><a href="#JS数组的一些常用方法" class="headerlink" title="JS数组的一些常用方法"></a>JS数组的一些常用方法</h2><p>这里介绍一些我在写算法的过程中总结的常用的操作数组的方法：</p><p>新建一个数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peoples=[<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;sherlock&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;david&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">45</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">34</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jerry&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">16</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;rita&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">103</span>&#125;<br>]<br></code></pre></div></td></tr></table></figure><p>以下的方法均基于此数组进行操作</p><h3 id="1-flier"><a href="#1-flier" class="headerlink" title="1.flier()"></a>1.flier()</h3><p>  Array.prototype.fliter()，返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peopleFliter=peoples.filter(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(peopleFliter)<br></code></pre></div></td></tr></table></figure><h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map()"></a>2.map()</h3><p>  对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。所有的 <code>Map</code> 对象实例都会继承 <code>Map.prototype</code></p><p>  map在实际使用常用于数组的去重等操作，由于js中没有Hashmap,但Hashmap其实是map的底层实现，通过map.has()和map.set()的配合可以实现去除数组重复值的效果。map这里只是简单的介绍下，后续还需更细致的去理解</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> peopleNames=peoples.map(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> names.name<br>&#125;)<br><span class="hljs-built_in">console</span>.log(peopleNames)<br></code></pre></div></td></tr></table></figure><p>  如果放在浏览器中执行会看到以下结果,也就是上述所说的键值对的存储方式：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;sherlock&#x27;</span>, <span class="hljs-string">&#x27;david&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-string">&#x27;rita&#x27;</span>]<br><span class="hljs-number">0</span>: <span class="hljs-string">&quot;sherlock&quot;</span><br><span class="hljs-number">1</span>: <span class="hljs-string">&quot;david&quot;</span><br><span class="hljs-number">2</span>: <span class="hljs-string">&quot;tom&quot;</span><br><span class="hljs-number">3</span>: <span class="hljs-string">&quot;jerry&quot;</span><br><span class="hljs-number">4</span>: <span class="hljs-string">&quot;rita&quot;</span><br><span class="hljs-attr">length</span>: <span class="hljs-number">5</span><br>[[Prototype]]: <span class="hljs-built_in">Array</span>(<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h4 id="2-1-放上一道LeetCode原题"><a href="#2-1-放上一道LeetCode原题" class="headerlink" title="2.1 放上一道LeetCode原题"></a>2.1 放上一道LeetCode原题</h4><p> <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a> ：</p><p>通过哈希表找到重复的值很好理解也很方便，将元素一个一个存入map，如果已经存了那就返回这个重复的值。</p><p>题解：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (set.has(item)) <span class="hljs-keyword">return</span> item<br>        set.add(item)<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="3-find"><a href="#3-find" class="headerlink" title="3.find()"></a>3.find()</h3><p>  Array.prototype.find()，返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。也就是说这个方法仅返回一个元素的值,如果是要找到索引的话，可以使用findIndex()方法</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> findPeople=peoples.find(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> names.name===<span class="hljs-string">&#x27;tom&#x27;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="4-forEach"><a href="#4-forEach" class="headerlink" title="4.forEach()"></a>4.forEach()</h3><p>  Array.prototype.forEach(),对数组的每个元素执行一次给定的函数。forEach()被调用时，不会改变原数组,改方法按升序为数组中含有效值的每一项执行一次 <code>callback</code> 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。这里只是打印出了数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">peoples.forEach(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(names.name)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="5-some"><a href="#5-some" class="headerlink" title="5.some()"></a>5.some()</h3><p>  Array.prototype.some(),改方法测试数组中是不是<strong>至少</strong>有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。空数组在任何情况下返回的都是false</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hasAge=peoples.some(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(hasAge)<br></code></pre></div></td></tr></table></figure><h3 id="6-every"><a href="#6-every" class="headerlink" title="6.every()"></a>6.every()</h3><p>  Array.prototype.every(),该方法测试一个数组内的所有元素是否<strong>都能</strong>通过某个指定函数的测试。它同样返回一个布尔值。可以和some()对照着看</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hasAges=peoples.every(<span class="hljs-function">(<span class="hljs-params">names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age&lt;=<span class="hljs-number">50</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(hasAges)<br></code></pre></div></td></tr></table></figure><h3 id="7-reduce"><a href="#7-reduce" class="headerlink" title="7.reduce()"></a>7.reduce()</h3><p>Array.prototype.reduce(),该方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。返回值是函数累计处理的结果，这个特性就很适合用来计算数组的总和，<code>initialValue</code>作为第一次调用 <code>callback</code>函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。可以在MDN上了解更详细的传参介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> total=peoples.reduce(<span class="hljs-function">(<span class="hljs-params">currentTotal,names</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> names.age+currentTotal<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-built_in">console</span>.log(total)<br></code></pre></div></td></tr></table></figure><h4 id="7-1-放上一道LeetCode原题"><a href="#7-1-放上一道LeetCode原题" class="headerlink" title="7.1 放上一道LeetCode原题"></a>7.1 放上一道LeetCode原题</h4><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a>  ：</p><p>这道题的思路也简单，k次取反取最大值，首先想到的就是如果数组里有负数，那就需要优先对负数取反，如果没有负数，那就是只对数组中最小值取反，这样才能达到最大化的数组和。然后就是数组求和，写一个累加函数，自然而然就用上了reduce()，一气呵成。要想达到最优解还有优化的空间，这里只是我个人的题解思考。</p><p>题解:</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> largestSumAfterKNegations = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ans,dp<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        ans=<span class="hljs-built_in">Math</span>.min(...nums)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==ans)&#123;<br>                dp=i<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>              nums[dp]+=-<span class="hljs-number">2</span>*nums[dp]  <br>            &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            nums[dp]+=-<span class="hljs-number">2</span>*nums[dp]<br>        &#125;<br>        k--<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.reduce(add,<span class="hljs-number">0</span>)<br>&#125;;<br><span class="hljs-comment">//用于求和</span><br><span class="hljs-keyword">var</span>  add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> a, b </span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="8-includes"><a href="#8-includes" class="headerlink" title="8.includes()"></a>8.includes()</h3><p>   Array.prototype.includes(),该方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。使用 <code>includes()</code>比较字符串和字符时是区分大小写的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> items=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">const</span> includesN=items.includes(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>以上是比较常用的操作数组的方法，还有更多后续介绍</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</a></p><p>[2]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p><p>[3]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find</a></p><p>[4]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a></p><p>[5]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some</a></p><p>[6]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#%E8%AF%AD%E6%B3%95">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#%E8%AF%AD%E6%B3%95</a></p><p>[7]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a></p><p>[8]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#%E8%AF%AD%E6%B3%95">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#%E8%AF%AD%E6%B3%95</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之了解作用域</title>
    <link href="/posts/15242.html"/>
    <url>/posts/15242.html</url>
    
    <content type="html"><![CDATA[<h2 id="《You-Don’t-Know-JS》学习之了解作用域"><a href="#《You-Don’t-Know-JS》学习之了解作用域" class="headerlink" title="《You Don’t Know JS》学习之了解作用域"></a>《You Don’t Know JS》学习之了解作用域</h2><p>​    如果说你已经学会了如何在js里定义一个变量或常量，那你就已经接触到了作用域了，几乎所有的编程语言都定义一个变量后，你可以对这个变量进行输出、修改、赋值等操作。那么这里其实隐含了一个条件，为什么你能进行这些操作呢。其实，在定义完变量后，程序会存储变量中的值，之后便能对其进行访问或修改，而你可以把这一种能够访问赋值的能力当成一种状态，就好比你在小区能去小区楼下超市买东西，小区外面能进去吗？当然一定条件也可以。可如果说什么是军事基地呢？外部人员能够访问吗？显然不太可能。那么对于你定义的变量来说，有的可以很容易访问到，有的则需要一定的条件，才能获得这种访问的状态。</p><p>​    那么在什么时候访问？访问哪里，就需要一套规章制度来管理了，这样一种设计良好的规则就叫做作用域。作用域并不是js所特有的，但是在js中作用域有着一些特有的区别。</p><p>​    Js虽然是一门解释执行的语言，但也是一门编译语言，需要编译器对源代码进行编译。如果了解过js的发展的话，不难发现谷歌的V8引擎极其出色的编译性能也是推动js发展的一大动力。</p><p>​    传统的编译语言在源代码执行前有以下三个步骤，统称为编译：词法分析，语法分析，代码生成。了解这个有助于后面的理解。</p><h2 id="1-引擎的查询"><a href="#1-引擎的查询" class="headerlink" title="1.引擎的查询"></a>1.引擎的查询</h2><p>​    在js中有一个比较特别的词，叫做“执行上下文”。大部分情况js的代码编译发生在执行前的那段极短的时间，所以理解作用域是很重要的一个环节。至于引擎是如何工作的，显然超出了我目前的学习范围，这里只讲下书中说提到的“LHS查询”和“RHS查询”，这个其实是数学中的内容，LHS就是等式左边的意思，RHS同理。参考书中的例子，如果我在控制台输入一个变量b，引擎就会去找到b的值，如果没有找到，就会抛出RaferenceError的错误，这个时候是RHS查找。如果输入的是b=3，引擎就会在作用域中去找到b的值，并且为之赋值为3，如果没有就会向外层的作用域一层一层找过去，这里就是LHS查找。</p><p>简要的概括的话就是：LHS就是查找标志符以分配值；RHS则是查找需要使用的标志符。</p><p>那么这一道例题就很好理解了</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;<br><span class="hljs-keyword">var</span> b=a<br><span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">var</span> c=foo(<span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure><p>这里一共有3个LHS查询和4个RHS查询</p><h3 id="1-1-作用域的嵌套"><a href="#1-1-作用域的嵌套" class="headerlink" title="1-1.作用域的嵌套"></a>1-1.作用域的嵌套</h3><p>​    如果对上述例子加以修改,将b的定义放在函数的外边，你会发现即使函数中b没有定义，依然会拿到值。这是因为作用域在按名称查找变量的这一套规则，通常是需要顾及到多个作用域的，但b在当前的函数作用域找不到的时候，回继续在外层的作用域去找，直到全局作用域。作用域的嵌套会产生一个神奇的东西，就是“闭包”，这里先不提。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>)</span>&#123;<br><span class="hljs-keyword">return</span> a+b<br>&#125;<br><span class="hljs-keyword">var</span> b=<span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> c=foo(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//4</span><br></code></pre></div></td></tr></table></figure><h3 id="1-2-异常"><a href="#1-2-异常" class="headerlink" title="1-2.异常"></a>1-2.异常</h3><p>​    当一个变量在所有的作用域中都找不到声明的时候，就会“报错”，之前提到了引擎是有LHS查询和RHS查询的，由于在ES5中引入了，“严格模式这个概念”，这里也会有所区别：</p><p>​    ①RHS查询如果找不到的话，就会抛出ReferenceError，如果找到了，但是对变量的值进来了不当的操作，比如对一个const变量赋值，就会抛出TypeError。</p><p>​    ②严格模式下的LHS查询失败的话也会抛出ReferenceError,但是在非严格模式下，也就是没有strict mode，LHS查询如果在全局也找不到改变量的话，就会自动创建一个改名称的变量返回给引擎</p><h2 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h2><p>​    在看到这已经对作用域有了大致的了解了，而文中提到的全局作用域、函数作用域，这之间又有什么样的关系，还有没有其他的作用域？就需要另起篇幅来讲解了。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup">https://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【第二期】vue3 工具函数源码阅读</title>
    <link href="/posts/46326.html"/>
    <url>/posts/46326.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>很感谢若川大佬组织的源码阅读</p><p>以下为原文：<a href="https://juejin.cn/post/6994976281053888519">https://juejin.cn/post/6994976281053888519</a></p></blockquote><p>​    源码阅读在我看来极具挑战，一方面是我没有系统的学过vue，甚至于官方文档也没有看过。所以在了解到这次的源码阅读活动跟框架关联不大的时候，对于框架源码阅读的压力也减轻了不少。而且跟着若川大佬的笔记入手，能够很有效的去分析问题。那么这里就开始第二期的源码阅读~</p><h2 id="1-阅读开源项目"><a href="#1-阅读开源项目" class="headerlink" title="1.阅读开源项目"></a>1.阅读开源项目</h2><p>​    首先给到项目的地址：<a href="https://github.com/vuejs/vue-next">https://github.com/vuejs/vue-next</a></p><p>​    在github上找项目的时候，首先就是找到带.md后缀的文档，打开来看。github上在每次新建仓库的时候都会有个选项是否需要添加ReadMe.md这个文件，这个就是用来写一些项目配置相关的东西。首先阅读readme也是一个初步的对项目的了解。由于大部分的开源项目都是英文的，为了节约时间便于阅读，可以借助DeepL翻译器来配合阅读。</p><blockquote><p>DeepL翻译器:<a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></p></blockquote><p>这里附上项目目录结构的部分内容：</p><ul><li>reactivity:reactivity系统。它可以作为一个与框架无关的包独立使用。</li></ul><ul><li>runtime-core:与平台无关的运行时核心。包括虚拟Dom渲染器、组件实现和JavaScript APIs的代码。针对特定平台的高阶运行时（即自定义渲染器）可以用这个包来创建。</li></ul><ul><li>runtime-dom: 以浏览器为目标的运行时。包括处理本地DOM API、属性、属性、事件处理程序等。</li></ul><ul><li>runtime-test:用于测试的轻量级运行时。可以在任何JavaScript环境中使用，因为它 “渲染 “了一棵纯JavaScript对象的树。该树可以用来保证正确的渲染输出。还提供了用于序列化树、触发事件和记录更新过程中执行的实际节点操作的实用程序。</li></ul><ul><li>server-renderer:用于服务器端渲染的包。</li></ul><ul><li>compiler-core:平台无关的编译器核心。包括编译器的可扩展基础和所有平台无关的插件。</li></ul><ul><li>compiler-dom:带有专门针对浏览器的附加插件的编译器。</li></ul><ul><li>compiler-ssr:编译器，产生为服务器端渲染而优化的渲染函数。</li></ul><ul><li><p>template-explorer:一个用于调试编译器输出的开发工具。你可以运行 nr dev template-explorer 并打开它的 index.html 来获得一个基于当前源代码的模板编译副本。</p><p>​    模板探索器的live版本也是可用的，它可以用来为编译器的错误提供副本。你也可以从部署日志中挑选特定提交的部署。</p></li><li><p>shared:多个软件包之间共享的内部实用程序（尤其是运行时和编译器软件包使用的环境无关的实用程序）。</p></li></ul><ul><li>vue:面向公众的 “完整构建”，包括运行时和编译器。</li></ul><h3 id="1-2-打包构建代码"><a href="#1-2-打包构建代码" class="headerlink" title="1-2.打包构建代码"></a>1-2.打包构建代码</h3><p>​    先将项目clone到本地，由于项目中使用的是TS，但我没学过TS，所以参考若川大佬的文章，打包构建将TS转为JS。这里首先需要安装Node.js,由于我之前安过，这里就不再重复步骤，可以通过node -v 判断自己是否已经安装了。先全局安装yarn，直接cd到项目文件夹去添加依赖。</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br><br>npm install --global yarn<br>yarn <br>yarn build<br></code></pre></div></td></tr></table></figure><p>build完之后可以在vue-next\packages\shared\dist 这个文件夹里看到.js的文件</p><h3 id="1-3-生成sourcemap调试源码"><a href="#1-3-生成sourcemap调试源码" class="headerlink" title="1-3.生成sourcemap调试源码"></a>1-3.生成sourcemap调试源码</h3><p>​    在package.json中添加上</p><figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;dev:sourcemap&quot;</span>: <span class="hljs-string">&quot;node scripts/dev.js --sourcemap&quot;</span><br>    &#125;<br></code></pre></div></td></tr></table></figure><p>然后</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">yarn</span> dev:sourcemap<br></code></pre></div></td></tr></table></figure><p>即可执行，生成sourcemap，控制台会给出生成的地址，这时候随便找个页面引入改文件，启动服务即可调试源码。</p><h2 id="2-调试源码"><a href="#2-调试源码" class="headerlink" title="2.调试源码"></a>2.调试源码</h2><p>​    在打好断点开始调试。首先看到的是下面这些</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">export const createApp = ((...args) =&gt; &#123;<br>  const app = ensureRenderer().createApp(...args)<br><br>  if (__DEV__) &#123;<br>    injectNativeTagCheck(app)<br>    injectCompilerOptionsCheck(app)<br>  &#125;<br>//省略<br>&#125;<br></code></pre></div></td></tr></table></figure><p>官方文档的解释是：每个 Vue 应用都是通过用 <code>createApp</code> 函数创建一个新的应用实例开始的</p><p>这里就是创建新的应用实例的第一步，然后看到if语句中有个 DEV ,于是去查了下，初步看来 DEV 是个bool类型的，从字面上理解起来有点像，springboot配置开发环境时用到的:application-dev和application-prod类似，查阅相关资料，DEV也确实就是在vue构建开发资源时，用于判断开发环境的一个常量，当处于开发环境时，DEV值为true,处于生产环境时，DEV值为false。</p><p>然后接下来会进入到ensureRenderer()函数的内部</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">function ensureRenderer() &#123;<br>  return (<br>    renderer ||<br>    (renderer = createRenderer&lt;Node, Element | ShadowRoot&gt;(rendererOptions))<br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个地方可能是把创建完的对象返回过去了，这里不太懂，然后逐步调试，后面的API也看不懂了，就先不看。进入这一期的正题。</p><h2 id="3-工具函数"><a href="#3-工具函数" class="headerlink" title="3.工具函数"></a>3.工具函数</h2><p>​    这里的一些函数还是可以看懂的，我就挑几个我看的懂的记录下~</p><h3 id="onRE："><a href="#onRE：" class="headerlink" title="onRE："></a>onRE：</h3><p>这个是用到了正则去进行筛选。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> onRE = <span class="hljs-regexp">/^on[^a-z]/</span>;<br><span class="hljs-keyword">const</span> isOn = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> onRE.test(key);<br></code></pre></div></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove:"></a>remove:</h3><p>这里很容易看出来是对数组进行的操作，splice（），在i位置删除1个元素，可以在sublime里把这个函数放进去自己写个输入输出测试下。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> remove = <span class="hljs-function">(<span class="hljs-params">arr, el</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> i = arr.indexOf(el);<br>    <span class="hljs-keyword">if</span> (i &gt; -<span class="hljs-number">1</span>) &#123;<br>        arr.splice(i, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="hasOwnProperty："><a href="#hasOwnProperty：" class="headerlink" title="hasOwnProperty："></a>hasOwnProperty：</h3><p>这里在原型里常用到，用于判断是不是自己的</p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;<br></code></pre></div></td></tr></table></figure><h3 id="is…"><a href="#is…" class="headerlink" title="is…:"></a>is…:</h3><p>这后面一大段代码就是用来判断类型的，不过不清楚为什么要加上$1,可能是为了防止重名？</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">const isArray$1 = Array.isArray;<br>const isMap$1 = (val) =&gt; toTypeString$1(val) === &#x27;[object Map]&#x27;;<br>const isSet$1 = (val) =&gt; toTypeString$1(val) === &#x27;[object Set]&#x27;;<br>const isDate$1 = (val) =&gt; val instanceof Date;<br>const isFunction$1 = (val) =&gt; typeof val === &#x27;function&#x27;;<br>const isString$1 = (val) =&gt; typeof val === &#x27;string&#x27;;<br>const isSymbol = (val) =&gt; typeof val === &#x27;symbol&#x27;;<br>const isObject$1 = (val) =&gt; val !== null &amp;&amp; typeof val === &#x27;object&#x27;;<br></code></pre></div></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p>​    还有很多工具函数不能一一列举出来。看到现在，大部分的函数仔细分析还是能理解的，而且源码的命名在这里就能看出很规范，像动词+名词，在一定程度上能够理解这个函数是想要干什么。而且从开头clone项目到分析源码的这个过程，自己动手操作下来，阅读源码也不像是一件“高不可攀”的事情，可能刚开始有点吃力，但就算没有学过框架，只要能花些时间，也能够有很大的收获。</p>]]></content>
    
    
    <categories>
      
      <category>VUE</category>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo之优化文章链接</title>
    <link href="/posts/fb91dbe9.html"/>
    <url>/posts/fb91dbe9.html</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo之优化文章链接"><a href="#Hexo之优化文章链接" class="headerlink" title="Hexo之优化文章链接"></a>Hexo之优化文章链接</h2><p>​    在给博客绑定完域名后，终于实现了直接通过域名访问。但是总觉得又少了什么，能不能在搜索引擎中找到我的博客呢？于是在一番搜索下，无一例外的都是提示没有找到该URL。又是在一番搜索之下，了解到需要给自己的网站做SEO，提交SiteMap给搜索引擎。期间在提交SiteMap过程中，看到提交的URL文章结构层级实在复杂，文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，这相当于访问了三层目录，不利于SEO。最终我在github上找到了合适的解决方案。</p><blockquote><p><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件</p><p>A Hexo plugin to generate static post link based on post titles.</p></blockquote><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>​    先在博客文件夹下安装改插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs npm">npm install hexo-abbrlink --save<br></code></pre></div></td></tr></table></figure><h2 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2.配置插件"></a>2.配置插件</h2><p>​    在项目的_config.yml文件中加上permalink字段</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yykaoyanupup.xyz/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">posts/:abbrlink.html</span>  <span class="hljs-comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span><br><span class="hljs-attr">abbrlink:</span><br>    <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span>   <span class="hljs-comment">#算法： crc16(default) and crc32</span><br>    <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span>     <span class="hljs-comment">#进制： dec(default) and hex</span><br></code></pre></div></td></tr></table></figure><h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3.实现细节"></a>3.实现细节</h2><p>可以看到abbrlink配置了alg和rep，这里简单介绍下配置内容</p><h3 id="3-1：CRC"><a href="#3-1：CRC" class="headerlink" title="3-1：CRC"></a>3-1：CRC</h3><p>​    CRC本身是“冗余校验码”,在计算机网络中有接触过，在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段 。如果要实现差错检验，必须在发送数据的后面增加校验码，否则实现不了。校验码的值由校验方法决定。CRC循环冗余校验的细节这里先不做介绍，一般网卡的生成多项式都是CRC-16或者32。位数很多。这样就降低漏检率。比奇偶校验强多，效率也高。CRC32就是表示会产生一个32bit（8位十六进制数）的校验值。</p><h3 id="3-2：hex"><a href="#3-2：hex" class="headerlink" title="3-2：hex"></a>3-2：hex</h3><p>​    Hex是一种编码吗，就是把一个8位的字节数据用两个十六进制数展示出来，编码时，将8位二进制码重新分组成两个4位的字节，其中一个字节的低4位是原字节的高四位，另一个字节的低4位是原数据的低4位，高4位都补0，然后输出这两个字节对应十六进制数字作为编码。Hex编码后的长度是源数据的2倍</p><h2 id="4-优化效果"><a href="#4-优化效果" class="headerlink" title="4.优化效果"></a>4.优化效果</h2><p>配置不同校验码和编码格式会对生成的ID有不同的效果，这里展示一些样例：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">crc16 &amp; hex<br>https://post.zz173.com/posts/<span class="hljs-number">66</span>c8.html<br><br>crc16 &amp; dec<br>https://post.zz173.com/posts/<span class="hljs-number">65535</span>.html<br>crc32 &amp; hex<br>https://post.zz173.com/posts/<span class="hljs-number">8</span>ddf18fb.html<br><br>crc32 &amp; dec<br>https://post.zz173.com/posts/<span class="hljs-number">1690090958</span>.html<br></code></pre></div></td></tr></table></figure><p>配置完成后通过hexo三连会发现，文章的层次目录也发生了改变，文章新增了abbrlink字段，这样链接就确定下来了，无论怎样更改文章都不会对链接产生影响。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之小序</title>
    <link href="/posts/38382.html"/>
    <url>/posts/38382.html</url>
    
    <content type="html"><![CDATA[<p>​    如果说对于一个语言，首先学习的是语法。那么对于js来说，大多数人都不是从学习”语法“开始的，而是直接使用js。在我一开始接触到这门语言，要如何理解js，就是一道迈不过去的坎、悬在头上的达摩克利斯之剑。</p><p>​    当我在没有系统的学习js之前，处在仅且会用的阶段，对于var、let、const的使用也是不求甚解，用来定义变量或常量，但要问起来又什么差别？不好意思，不知道，不了解。但就是这样在短时间内速成的js语法，如果不要求第二天立马弄个项目出来，这点东西也足够应付很多场景了，比如说写算法题。js中很重要的的闭包、原型、promise….，这些东西在写算法中并不是必须的，也就是抱着这样的侥幸心理，靠着几天速成的js基础，开始了算法之路。</p><p>​    不过几天的速成之路倒也不是什么都没学到，在fcc上靠着一道又一道的基础例题，边看MDN，边看一些技术文章。从只会var一个变量，靠着其他语言基础写点遍历的js小白，也算是略懂一些js的特性，容易弄混淆的this指向、闭包究竟是个什么东西？、手写一个promise、听起来极其高大上的函数柯里化。我就是在这样一边耳濡目染个个不知所以的名词，被前端学习群里的大佬发的面试题pua，一边穷尽“毕生所学”来刷算法，至终发觉，学海无涯，没有一个可靠的基础，所学就如大海之扁舟，无归无得。对我来说，扎实的前端基础学习迫在眉睫。</p><p>​    有人认为前端简单，确实，相比于其他语言，弱化类型就已经极大降低了js的使用学习成本，但js上手容易并不代表学起来容易，也更不代表前端学起来容易。前端已经不复当日“吴下阿蒙”，遍观js的发展历程，标准化ECMAScrip，前端工程化，js框架出现更有typtscript、rust、webAssembly等等引领潮流。怎么看，前端都不仅仅是只需要个切图写界面的码农就能胜任的。</p><p>​    故而，学习的高度决定了能力的高度。今日以此为记，以学促成，以文促学，不忘学之本末。</p>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode上的那些计数排序</title>
    <link href="/posts/62795.html"/>
    <url>/posts/62795.html</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>​        时间复杂度：O(n+k)，即线性时间，k为给定数据中的最大值（k为整数范围），而其他的排序方法则最好的情况才是O(nlgn)。这是计数排序用空间换取时间的便利，也是计数排序只在特定情况才能使用的缺陷。</p><p>​        空间复杂度：总的空间复杂度为O(n+k)，因为用到了另一个数组O(k)用于存储。</p><blockquote><p>看完此文可以在力扣上轻松解决以下问题：</p><p><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></p><p><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></p><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p><a href="https://leetcode-cn.com/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></p></blockquote><p>​        偶然间在力扣上看到一排序的题，便点了进去。<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>题目意思很简单将数组升序排列，如果是为了快速解题的话，直接出结果，用sort()方法一步就行，但看了看难度，怎么是个中等题。于是在题库的归类里赫然看到“<strong>计数排序</strong>”这四个大字。那便来学习下计数排序</p><p>​        计数排序英文名：Counting Sort，顾名思义。注意这里有个中文读音很像的<strong>“基数排序”</strong>，两者是有所不同的，基数排序英文是：Radix sort，radix英文中意思是基数，而基数在数学中是集合论的一个概念，两个能够建立元素间一一对应的集合称为互相对等集合，基数排序这里暂且不提。</p><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>​        首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。有另一种不借助额外的存储空间的，只使用计数数组作为辅助存储，但是这种修改后的并不稳定。</p><hr><p>​    In computer science, <strong>counting sort</strong> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm.                                                                     ——from wikipedia</p><hr><h3 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h3><p>​        通过数组实现，将原数组中整数的值，作为索引，在另一个数组上对应的索引累加。也就是说，不通过比较，而是索引下标确定值的位置。然后遍历目标数组，依次输出就是排序后的结果。一般用于比较小的正整数，太大会造成目标数组空间的浪费。keys 可以理解为 index的键， 既然将值作为索引，那负数是不支持的。但是为了对负数也能够排序，在初始化数组空间的时候，可以通过加上一个固定的值（max-min+1），来实现对负数的取正。 </p><h3 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h3><p>​        下面以力扣的912.排序数组为例：</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">Input:<br><span class="hljs-string">[1, 3, 2, 8, 5, 1, 5, 1, 2, 7]</span><br>Output:<br><span class="hljs-string">[1, 1, 1, 2, 2, 3, 5, 5, 7, 8]</span><br></code></pre></div></td></tr></table></figure><p>首先需要初始化三个变量，max用于计算数据最大值，dp初始化为空数组用于输出，ans用于构建计数数组</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​        这个时候就算是写完了，但是拿去测试的时候你会发现报错了。为什么呢？题目中给出的数据范围是：[-50000,50000]，这时候你看完了前面的内容可能会想了，计数排序无法适用于负数的原因就是将值作为索引，那么索引一定不能是负的。出错的原因就在这！前面也提到了有解决的办法，其实很简单。只需要稍加修改.</p><p>​        添加变量min用于计算数据中的最小值，在数组初始化的时候，空间大小初始化为max-min+1，也就是间接的将负数对应的索引”取正“。这里在后面的几个循环中需要注意循环截止的条件！</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> min=<span class="hljs-built_in">Math</span>.min(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max-min+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d-min]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max-min+<span class="hljs-number">1</span>; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k+min);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>​        写到此，计数排序的代码已经完成了，有兴趣的可以试试原地排序。</p><p>​        特别需要提到的，在翻阅了很多资料中，并没有给出过Js的计数排序模板，Js的数组也不是实际意义上的数组，而是对象，还有很多方法可以用来优化以上代码，但思路始终是这个思路，这里暂且不提。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p>[2]:<a href="https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/">https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/</a></p><p>[3]:<a href="https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c">https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
