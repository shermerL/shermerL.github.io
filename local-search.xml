<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《You Don&#39;t Know JS》学习之小序</title>
    <link href="/2021/11/21/%E3%80%8AYou%20Don%E2%80%99t%20Know%20JS%E3%80%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B0%8F%E5%BA%8F/"/>
    <url>/2021/11/21/%E3%80%8AYou%20Don%E2%80%99t%20Know%20JS%E3%80%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B0%8F%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>​    如果说对于一个语言，首先学习的是语法。那么对于js来说，大多数人都不是从学习”语法“开始的，而是直接使用js。在我一开始接触到这门语言，要如何理解js，就是一道迈不过去的坎、悬在头上的达摩克利斯之剑。</p><p>​    当我在没有系统的学习js之前，处在仅且会用的阶段，对于var、let、const的使用也是不求甚解，用来定义变量或常量，但要问起来又什么差别？不好意思，不知道，不了解。但就是这样在短时间内速成的js语法，如果不要求第二天立马弄个项目出来，这点东西也足够应付很多场景了，比如说写算法题。js中很重要的的闭包、原型、promise….，这些东西在写算法中并不是必须的，也就是抱着这样的侥幸心理，靠着几天速成的js基础，开始了算法之路。</p><p>​    不过几天的速成之路倒也不是什么都没学到，在fcc上靠着一道又一道的基础例题，边看MDN，边看一些技术文章。从只会var一个变量，靠着其他语言基础写点遍历的js小白，也算是略懂一些js的特性，容易弄混淆的this指向、闭包究竟是个什么东西？、手写一个promise、听起来极其高大上的函数柯里化。我就是在这样一边耳濡目染个个不知所以的名词，被前端学习群里的大佬发的面试题pua，一边穷尽“毕生所学”来刷算法，至终发觉，学海无涯，没有一个可靠的基础，所学就如大海之扁舟，无归无得。对我来说，扎实的前端基础学习迫在眉睫。</p><p>​    有人认为前端简单，确实，相比于其他语言，弱化类型就已经极大降低了js的使用学习成本，但js上手容易并不代表学起来容易，也更不代表前端学起来容易。前端已经不复当日“吴下阿蒙”，遍观js的发展历程，标准化ECMAScrip赫然登场，前端工程化，js框架三足鼎立更有typtscript、rust、webAssembly等等引领潮流。怎么看，前端都不仅仅是只需要个切图写界面的码农就能胜任的。</p><p>​    故而，学习的高度决定了能力的高度。今日以此为记，以学促成，以文促学，牢记始终，不忘学之本末。</p>]]></content>
    
    
    <categories>
      
      <category>你不知道的JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的查找排序算法</title>
    <link href="/2021/11/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E6%89%BE%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/18/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E6%89%BE%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-查找算法"><a href="#1-查找算法" class="headerlink" title="1. 查找算法"></a>1. 查找算法</h3><h5 id="顺序查找："><a href="#顺序查找：" class="headerlink" title="顺序查找："></a>顺序查找：</h5><p>​    顺序查找又叫做线性查找，对于顺序表和链表都是适用的，它的基本思想就是从第一个元素开始，按顺序遍历待查找序列，直到找出给定目标或者查找失败。</p><h5 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h5><p>​    又叫折半查找，它要求列表必须是有序的。它的原理是每次都把待比较元素target和列表中间的元素mid进行比较，如果target小于mid，那么target再和位于mid前半部分的元素进行比较，并且再次选择中间元素进行比较，直到比较完所有元素为止。</p><blockquote><p>二分查找是一个理解简单但是细节十分考究的算法，对于比较区间的选择需要很全面才行</p></blockquote><h3 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2.排序算法"></a>2.排序算法</h3><h5 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h5><p>​    它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小（大）的元素会经由交换慢慢“浮”到数列的顶端。</p><h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><p>​    是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大） 元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><blockquote><p>参考资料：</p><p>[1]严蔚敏. 数据结构(C语言版)[J]. 计算机教育.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见数据结构</title>
    <link href="/2021/11/18/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/11/18/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="常见数据结构："><a href="#常见数据结构：" class="headerlink" title="常见数据结构："></a>常见数据结构：</h2><p>​    数据结构是相互之间存在一种或多种特定关系的数据元素的集合。它的核心内涵是分解与抽象，并得到软件开发过程中需要用到的逻辑结构。</p><h4 id="数组（Array）："><a href="#数组（Array）：" class="headerlink" title="数组（Array）："></a>数组（Array）：</h4><p>​    将具有相同类型的若干数据组织在一起的集合，这是一种最基本而且也是一种最经常使用的数据结构</p><h4 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a>栈（Stack）：</h4><p>​    一种特殊的线性表，只能在一个表的固定端进行数据节点的插入和删除操作，栈正是一种按照后进先出（LIFO）的原则来存储数据的数据结构</p><h4 id="队列（Queue）："><a href="#队列（Queue）：" class="headerlink" title="队列（Queue）："></a>队列（Queue）：</h4><p>​    和栈类似，但不同的是，它是在一端执行入队操作，而在另一端进行出队操作</p><h4 id="链表（Linked-List）："><a href="#链表（Linked-List）：" class="headerlink" title="链表（Linked List）："></a>链表（Linked List）：</h4><p>​    它和数组一样，也是一组数据的集合，但和数组不一样的是， 它并不是一组连续的数据集合，而是通过指针连接在一起的。</p><h4 id="树（Tree）："><a href="#树（Tree）：" class="headerlink" title="树（Tree）："></a>树（Tree）：</h4><p>​    这是一种典型的非线性结构，之所以叫做“树”，是因为它的结构看起来就像一颗倒过来的树，它只有一个根结点，但可以有多个后继节点。</p><h4 id="堆（Heap）："><a href="#堆（Heap）：" class="headerlink" title="堆（Heap）："></a>堆（Heap）：</h4><p>​    它是一种特殊的树型结构，它的特点是根结点的值是所有节点中最大或者最小的，而且根结点的子节点也是一个堆结构。</p><h4 id="图（Graph）："><a href="#图（Graph）：" class="headerlink" title="图（Graph）："></a>图（Graph）：</h4><p>​    这也是一种非线性数据结构，在图结构中，数据节点称为顶点，顶点之间的连线称为边。</p><h4 id="散列表（Hash）："><a href="#散列表（Hash）：" class="headerlink" title="散列表（Hash）："></a>散列表（Hash）：</h4><p>​    其实就是哈希表，只不过一个是音译。这种数据结构来源于散列函数，它的思想是如果存在 x，那么就必然有一个唯一的存储位置 f(x)可以找到 x，这样通过数学函数就直接计算出 x 的存储位置而不用在进行比较、查找以后才知道。</p><p>ps:数据结构的内容远不是几句话能够说完的，尤其是树和图这一块，这里只是汇总常见的数据结构，做个梗概</p><blockquote><p>参考资料：</p><p>[1]严蔚敏. 数据结构(C语言版)[J]. 计算机教育.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络拓扑结构</title>
    <link href="/2021/11/18/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/"/>
    <url>/2021/11/18/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><h4 id="星型结构："><a href="#星型结构：" class="headerlink" title="星型结构："></a>星型结构：</h4><p>​    是指各计算机以星型方式连接成网。网络有中央节点，其他结点（工作站、服务器）都与中央节点直接相连，这种结构以中央结点为中心，因此又称为集中式网络。具有结构简单、便于管理、控制简单、网络延迟时间小、传输误差低等特点。但缺点也是明显的：可靠性较低、资源共享能力较差、线路利用率低。</p><blockquote><p>节点：指的是一个网络端口，如交换机、网关、路由器、防火墙等设备的端口</p></blockquote><h4 id="总线型结构："><a href="#总线型结构：" class="headerlink" title="总线型结构："></a>总线型结构：</h4><p>​    是指各工作站和服务器均挂在一条总线上，各工作站地位平等，无中心节点控制，它结构简单、可扩充性好、安装容易，但维护困难。</p><h4 id="环型结构："><a href="#环型结构：" class="headerlink" title="环型结构："></a>环型结构：</h4><p>​    由网络中若干结点通过通信链路首尾相连形成一个闭合的环，这种结构使公共传输电缆组成环状，数据在环路中沿着一个方向在各个节点间传输，信息从一个节点传到另一个节点。它实时性强、传输控制容易，但维护困难，可靠性不高。</p><blockquote><p>结点：指的是一台具体的网络设备，因为它们通常连接多个“节点”，故称之为“结点”</p><p>链路：是两个节点间的线路</p></blockquote><h4 id="网状结构："><a href="#网状结构：" class="headerlink" title="网状结构："></a>网状结构：</h4><p>​    它是指每台设备之间均有点到点的链路连接，这种连接不经济，只有每个站点都要频繁发送信息时才使用这种方法。它的安装也比较复杂，但系统可靠性高，容错能力强。有时也称为分布式结构。</p><blockquote><p>通路：是从发出信息的节点到接收信息的节点之间的一串节点和链路的组合</p></blockquote><h4 id="树型结构："><a href="#树型结构：" class="headerlink" title="树型结构："></a>树型结构：</h4><p>​    这是一种分级的集中控制式网络，与星型相比，它的通信线路总长度短，成本较低、节点易于扩充、寻找路径方便，但除了叶节点及其相连的线路外，任一节点或其相连的线路故障都会使系统受到影响。</p><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈语义化标签</title>
    <link href="/2021/11/17/%E6%B5%85%E8%B0%88%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/11/17/%E6%B5%85%E8%B0%88%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><p>​        语义化标签是HTML5的新特性，赋予标签含义。给某块内容用上一个最恰当最合适的标签，使页面有良好的结构，页面元素有含义，更利于开发者、程序和其他设备对于标签的理解。</p><p>​        语义化标签是应用于无障碍的一个重要的实践，在网页开发中，可访问性是指网页内容和用户界面可以被用户理解、浏览并与之交互。这里的用户包括有视觉障碍、听觉障碍或认知障碍的用户。所以语义化在软件、机器翻译等方面发挥着重要作用，同时搜索引擎也会通过语义化标签增强文章的SEO。</p><h3 id="1-常用的语义化标签"><a href="#1-常用的语义化标签" class="headerlink" title="1.常用的语义化标签"></a>1.常用的语义化标签</h3><p>​    </p><div class="table-container"><table><thead><tr><th>article</th><th>文章</th></tr></thead><tbody><tr><td>aside</td><td>侧边栏</td></tr><tr><td>main</td><td>主要内容</td></tr><tr><td>nav</td><td>导航栏</td></tr><tr><td>section</td><td>区域</td></tr><tr><td>header</td><td>页面的头部区域</td></tr><tr><td>footer</td><td>页面的尾部区域</td></tr><tr><td>mark</td><td>标记</td></tr><tr><td>ul</td><td>无序列表</td></tr><tr><td>form</td><td>表单</td></tr><tr><td>button</td><td>按钮</td></tr><tr><td>i</td><td>斜体</td></tr></tbody></table></div><h3 id="2-语义化标签的优点"><a href="#2-语义化标签的优点" class="headerlink" title="2.语义化标签的优点"></a>2.语义化标签的优点</h3><ul><li>语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是便于阅读、维护和理解</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO</li><li>用正确的标签做正确的事情</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈域名解析</title>
    <link href="/2021/11/17/%E6%B5%85%E8%B0%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/11/17/%E6%B5%85%E8%B0%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>​        既然提到域名解析，那就先了解下什么是域名。访问一个网站，首先就是输入网址，浏览器再补充些网址的协议，如http/https，就成为了URL，URL全称是：Uniform Resource Location，翻译过来就是<strong>统一资源定位符</strong>。统一资源定位符包含的信息指出了文件的位置以及浏览器应该怎么处理它，而域名是Domain name。URL其实就是包含了域名在内的这样一串信息组成的地址。</p><p>​        任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。而域名系统（Domain name system，简称DNS）是互联网使用的命名系统，用于把人们使用的机器名字转化为IP地址，一台连接在互联网上的主机有IP地址，也有便于记忆的主机名字。IP地址可以来唯一标记每台主机在网络里的位置，域名系统则是将主机名字转换为IP地址，极大简化了记忆流程。域名解析其实就是将域名转换为 IP 地址的过程。</p><h3 id="1-域名规则"><a href="#1-域名规则" class="headerlink" title="1.域名规则"></a>1.域名规则</h3><p>​        英文域名只能由26个英文字母、0～9十个数字以及“-”连字符号混合而成，不支持使用空格及一些特殊字符，比如!?/\;:@#$%^~_=+,*&lt;&gt;等英文域名不区分大小写，也可以是纯英文和数字域名，对于中文域名而言，则必须含有中文字符域名级数是从右至左按照“.”分隔的部分确定的，有几个“.”就是几级，一般情况下， 域名最好不超过五级，例如 a.com 是一级域名，而 a.b.com则是二级域名每一级域名长度的限制是63个字符，域名总长度则不能超过 253 个字符常见的通用顶级域名为：.biz .com .edu .gov .info .int .mil .name .net .org 国家顶级域名参照 ISO 3166-1 中的双字母代码生成，例如中国大陆为.cn，中国香港 为.hk，中国台湾为.tw，美国为.us 通用域名可以组合国家域名，标明所在地区（只要域名管理机构允许），例如.gov.cn</p><h3 id="2-域名解析类型"><a href="#2-域名解析类型" class="headerlink" title="2. 域名解析类型"></a>2. 域名解析类型</h3><p>​        其实在自己购买域名后，需要一个域名解析的步骤，一般来说买来的域名会自己解析出几条记录，这个时候就需要自己重新配置，将自己网站的IP绑定到记录上去，从而实现关联。</p><h5 id="A-记录解析："><a href="#A-记录解析：" class="headerlink" title="A 记录解析："></a>A 记录解析：</h5><p>​            A 记录就是 Address 记录，是用来指定域名对应的 IP 地址，通常是将网站服务指向服务器地址。</p><h5 id="CNAME-记录解析："><a href="#CNAME-记录解析：" class="headerlink" title="CNAME 记录解析："></a>CNAME 记录解析：</h5><p>​            如果服务器的地址发生变动，光靠A记录就不行了。这时候就需要用到 CNAME，它又叫别名解析，也就是允许多个域名对应服务器的主机名，这样即使服务器的 IP 地址发生变更，也不用更改解析记录，域名解析会自动依据主机名更新IP地址。如果A记录解析和CNAME记录解析并存，那么A记录解析将优先生效。</p><h5 id="MX-记录解析："><a href="#MX-记录解析：" class="headerlink" title="MX 记录解析："></a>MX 记录解析：</h5><p>​            即邮件交换记录，这种记录解析用于将以域名为结尾的电子邮件指向对应的邮件服务器，例如用户所用的邮件以 xxx 为结尾，那么就需要在域名管理中添加该域名的 MX 记录来处理所有以@xxx为结尾的邮件。</p><h3 id="3-泛域名解析"><a href="#3-泛域名解析" class="headerlink" title="3.泛域名解析"></a>3.泛域名解析</h3><p>​        针对一个域名下所有未单独指定的主机名的域名解析就是泛域名解析。泛域名解析一般用在IP指向上，做一条泛域名解析就可以把一个域名下的所有主机名都解析到同一个IP地址上去。</p><p>ps:前端常见面试题有一道：描述浏览器从输入网址到页面展示的过程，这里就需要去深入了解其中的关键点，这里暂且不提</p><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的网络命令和端口</title>
    <link href="/2021/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E5%92%8C%E7%AB%AF%E5%8F%A3/"/>
    <url>/2021/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E5%92%8C%E7%AB%AF%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-常用网络命令"><a href="#1-常用网络命令" class="headerlink" title="1.常用网络命令"></a>1.常用网络命令</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping:"></a>ping:</h4><p>​        这是在实际应用中使用频率极高的一个命令，主要用于确定网络的连通性，如果要判断计算机是否能联网，执行的第一 条命令就是 ping 命令。它的格式是：ping 主机名/域名/IP 地址</p><p><img src="/img/190649.jpg" alt=""></p><h4 id="ipconfig-ifconfig："><a href="#ipconfig-ifconfig：" class="headerlink" title="ipconfig/ifconfig："></a>ipconfig/ifconfig：</h4><p>​        当使用不带任何参数选项 ipconfig/ifconfig 命令时，显示每 个已经配置了的接口的 IP 地址、子网掩码和缺省网关值。其中在 Windows 中使用的是 ipconfig，而在 Mac 或 Linux 系统中，使用的是 ifconfig</p><h4 id="netstat："><a href="#netstat：" class="headerlink" title="netstat："></a>netstat：</h4><p>​        能够显示活动的 TCP 连接、计算机侦听的端口、以太网统计信息、IP 路由表、IPv4 以及 IPv6 统计信息，通过它可以了解网络当前的状态</p><h3 id="2-常用网络端口"><a href="#2-常用网络端口" class="headerlink" title="2.常用网络端口"></a>2.常用网络端口</h3><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th>服务/协议</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:left">21</td><td>FTP</td><td>FTP 服务器所开放的端口，用于上传、下载</td></tr><tr><td style="text-align:left">22</td><td>SSH</td><td>SSH 连</td></tr><tr><td style="text-align:left">23</td><td>Telnet</td><td>远程登录服务</td></tr><tr><td style="text-align:left">25</td><td>SMTP</td><td>SMTP 服务器所开放的端口，用于发送邮件</td></tr><tr><td style="text-align:left">80</td><td>HTTP</td><td>HTTP 协议默认端口号</td></tr><tr><td style="text-align:left">109</td><td>POP3</td><td>邮局协议端口号</td></tr><tr><td style="text-align:left">161</td><td>SNMP</td><td>网络管理协议端口号</td></tr><tr><td style="text-align:left">443</td><td>HTTPS</td><td>HTTPS 协议默认端口</td></tr><tr><td style="text-align:left">8080</td><td>www代理</td><td>一般的网站服务会开放此端口</td></tr></tbody></table></div><blockquote><p>参考资料：</p><p>[1]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>端口</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈计算机存储单位</title>
    <link href="/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/"/>
    <url>/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p>​        在计算机的内部，任何信息都被表示成二进制编码，二进制数据的每一位0或1是组成二进制信息的最小单位，称为一个“<strong>比特</strong>”(bit，或称作位元)，简称“位”，bit来源于binary digit，意思就是一个“二进制数字”，所以bit也是是计算机存储、运算、传输信息的最小单位。二进制信息的计量单位称为“<strong>字节</strong>”(Byte,或称作位组)，一个字节等于8个比特，通常b表示比特，B表示字节。</p><p>​        还有另外两个容易混淆的是“字”（word）和“字长”，<strong>字长</strong>等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，我们常说的电脑是64位或32位，就是指字长。而<strong>字</strong>则是用于度量各种数据类型的宽度，不同的计算机字的长度和组成不完全相同，一台机器在提供数据类型的时候，就需要给出一个基本的字的宽度。</p><h3 id="1-单位定义"><a href="#1-单位定义" class="headerlink" title="1.单位定义"></a>1.单位定义</h3><p>​        存储单位：存储在计算机硬盘或内存中的信息容量标准，最小计量单位是“位”（bit， 比特），一个比特位表示一个二进制的 0 或 1 在计算机中所占用的存储空间</p><p>​        传输单位：在计算机网络中称为带宽，宽带传输速率的单位为bit/s,也可以写为bps，bps 是 bit per second 的缩写，表示每秒钟传输多少比特位信息，这里的b不是指Byte字节，而是bit位。例如：带宽的单位是 100MB/S，这里其实指的是每秒传输 100 兆 位，而不是 100 兆字节数据，因此将位数需要除以 8 换算成字节数，也就是每秒传输 12.5 兆字节，即 100MBit/S = 12.5MByte/</p><h3 id="2-单位换算"><a href="#2-单位换算" class="headerlink" title="2.单位换算"></a>2.单位换算</h3><p>​        1 字节（Byte）= 8 位（bit） </p><p>​        1KB（Kilo Byte）= 1024B（Byte字节）</p><p>​        1MB（Mega Byte）= 1024KB </p><p>​        1GB（Giga Byte）= 1024MB </p><p>​        1TB（Tera Byte）= 1024G</p><blockquote><p>参考资料：</p><p>[1]:袁春风. 计算机系统基础[M]. 机械工业出版社, 2014.</p><p>[2]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode上的那些计数排序</title>
    <link href="/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>​        时间复杂度：O(n+k)，即线性时间，k为给定数据中的最大值（k为整数范围），而其他的排序方法则最好的情况才是O(nlgn)。这是计数排序用空间换取时间的便利，也是计数排序只在特定情况才能使用的缺陷。</p><p>​        空间复杂度：总的空间复杂度为O(n+k)，因为用到了另一个数组O(k)用于存储。</p><blockquote><p>看完此文可以在力扣上轻松解决以下问题：</p><p><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></p><p><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></p><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p><a href="https://leetcode-cn.com/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></p></blockquote><p>​        偶然间在力扣上看到一排序的题，便点了进去。<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>题目意思很简单将数组升序排列，如果是为了快速解题的话，直接出结果，用sort()方法一步就行，但看了看难度，怎么是个中等题。于是在题库的归类里赫然看到“<strong>计数排序</strong>”这四个大字。那便来学习下计数排序</p><p>​        计数排序英文名：Counting Sort，顾名思义。注意这里有个中文读音很像的<strong>“基数排序”</strong>，两者是有所不同的，基数排序英文是：Radix sort，radix英文中意思是基数，而基数在数学中是集合论的一个概念，两个能够建立元素间一一对应的集合称为互相对等集合，基数排序这里暂且不提。</p><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>​        首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。有另一种不借助额外的存储空间的，只使用计数数组作为辅助存储，但是这种修改后的并不稳定。</p><hr><p>​    In computer science, <strong>counting sort</strong> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm.                                                                     ——from wikipedia</p><hr><h3 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h3><p>​        通过数组实现，将原数组中整数的值，作为索引，在另一个数组上对应的索引累加。也就是说，不通过比较，而是索引下标确定值的位置。然后遍历目标数组，依次输出就是排序后的结果。一般用于比较小的正整数，太大会造成目标数组空间的浪费。keys 可以理解为 index的键， 既然将值作为索引，那负数是不支持的。但是为了对负数也能够排序，在初始化数组空间的时候，可以通过加上一个固定的值（max-min+1），来实现对负数的取正。 </p><h3 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h3><p>​        下面以力扣的912.排序数组为例：</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">Input:<br><span class="hljs-string">[1, 3, 2, 8, 5, 1, 5, 1, 2, 7]</span><br>Output:<br><span class="hljs-string">[1, 1, 1, 2, 2, 3, 5, 5, 7, 8]</span><br></code></pre></td></tr></table></figure><p>首先需要初始化三个变量，max用于计算数据最大值，dp初始化为空数组用于输出，ans用于构建计数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        这个时候就算是写完了，但是拿去测试的时候你会发现报错了。为什么呢？题目中给出的数据范围是：[-50000,50000]，这时候你看完了前面的内容可能会想了，计数排序无法适用于负数的原因就是将值作为索引，那么索引一定不能是负的。出错的原因就在这！前面也提到了有解决的办法，其实很简单。只需要稍加修改.</p><p>​        添加变量min用于计算数据中的最小值，在数组初始化的时候，空间大小初始化为max-min+1，也就是间接的将负数对应的索引”取正“。这里在后面的几个循环中需要注意循环截止的条件！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> min=<span class="hljs-built_in">Math</span>.min(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max-min+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d-min]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max-min+<span class="hljs-number">1</span>; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k+min);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        写到此，计数排序的代码已经完成了，有兴趣的可以试试原地排序。</p><p>​        特别需要提到的，在翻阅了很多资料中，并没有给出过Js的计数排序模板，Js的数组也不是实际意义上的数组，而是对象，还有很多方法可以用来优化以上代码，但思路始终是这个思路，这里暂且不提。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p>[2]:<a href="https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/">https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/</a></p><p>[3]:<a href="https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c">https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
