<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈计算机存储单位</title>
    <link href="/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/"/>
    <url>/2021/11/15/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机存储单位"><a href="#计算机存储单位" class="headerlink" title="计算机存储单位"></a>计算机存储单位</h2><p>​        在计算机的内部，任何信息都被表示成二进制编码，二进制数据的每一位0或1是组成二进制信息的最小单位，称为一个“<strong>比特</strong>”(bit，或称作位元)，简称“位”，bit来源于binary digit，意思就是一个“二进制数字”，所以bit也是是计算机存储、运算、传输信息的最小单位。二进制信息的计量单位称为“<strong>字节</strong>”(Byte,或称作位组)，一个字节等于8个比特，通常b表示比特，B表示字节。</p><p>​        还有另外两个容易混淆的是“字”（word）和“字长”，<strong>字长</strong>等于CPU内部用于整数运算的运算器位数和通用寄存器宽度，我们常说的电脑是64位或32位，就是指字长。而<strong>字</strong>则是用于度量各种数据类型的宽度，不同的计算机字的长度和组成不完全相同，一台机器在提供数据类型的时候，就需要给出一个基本的字的宽度。</p><h3 id="1-单位定义"><a href="#1-单位定义" class="headerlink" title="1.单位定义"></a>1.单位定义</h3><p>​        存储单位：存储在计算机硬盘或内存中的信息容量标准，最小计量单位是“位”（bit， 比特），一个比特位表示一个二进制的 0 或 1 在计算机中所占用的存储空间</p><p>​        传输单位：在计算机网络中称为带宽，宽带传输速率的单位为bit/s,也可以写为bps，bps 是 bit per second 的缩写，表示每秒钟传输多少比特位信息，这里的b不是指Byte字节，而是bit位。例如：带宽的单位是 100MB/S，这里其实指的是每秒传输 100 兆 位，而不是 100 兆字节数据，因此将位数需要除以 8 换算成字节数，也就是每秒传输 12.5 兆字节，即 100MBit/S = 12.5MByte/</p><h3 id="2-单位换算"><a href="#2-单位换算" class="headerlink" title="2.单位换算"></a>2.单位换算</h3><p>​        1 字节（Byte）= 8 位（bit） </p><p>​        1KB（Kilo Byte）= 1024B（Byte字节）</p><p>​        1MB（Mega Byte）= 1024KB </p><p>​        1GB（Giga Byte）= 1024MB </p><p>​        1TB（Tera Byte）= 1024G</p><blockquote><p>参考资料：</p><p>[1]:袁春风. 计算机系统基础[M]. 机械工业出版社, 2014.</p><p>[2]:谢希仁. 第7版. 计算机网络. 电子工业出版社.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode上的那些计数排序</title>
    <link href="/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/11/14/LeetCode%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>​        时间复杂度：O(n+k)，即线性时间，k为给定数据中的最大值（k为整数范围），而其他的排序方法则最好的情况才是O(nlgn)。这是计数排序用空间换取时间的便利，也是计数排序只在特定情况才能使用的缺陷。</p><p>​        空间复杂度：总的空间复杂度为O(n+k)，因为用到了另一个数组O(k)用于存储。</p><blockquote><p>看完此文可以在力扣上轻松解决以下问题：</p><p><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></p><p><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></p><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p><a href="https://leetcode-cn.com/problems/height-checker/">1051. 高度检查器</a></p><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p><a href="https://leetcode-cn.com/problems/0H97ZC/">剑指 Offer II 075. 数组相对排序</a></p></blockquote><p>​        偶然间在力扣上看到一排序的题，便点了进去。<a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>题目意思很简单将数组升序排列，如果是为了快速解题的话，直接出结果，用sort()方法一步就行，但看了看难度，怎么是个中等题。于是在题库的归类里赫然看到“<strong>计数排序</strong>”这四个大字。那便来学习下计数排序</p><p>​        计数排序英文名：Counting Sort，顾名思义。注意这里有个中文读音很像的<strong>“基数排序”</strong>，两者是有所不同的，基数排序英文是：Radix sort，radix英文中意思是基数，而基数在数学中是集合论的一个概念，两个能够建立元素间一一对应的集合称为互相对等集合，基数排序这里暂且不提。</p><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>​        首先计数排序从字面意思上就可以看出来，计算数字。这是一个稳定的非比较排序算法。一种基于特定范围内的键值的排序。通过计算具有不同键值的对象的数量，然后来得出每个对象在输出序列中的位置。有另一种不借助额外的存储空间的，只使用计数数组作为辅助存储，但是这种修改后的并不稳定。</p><hr><p>​    In computer science, <strong>counting sort</strong> is an algorithm for sorting a collection of objects according to keys that are small positive integers; that is, it is an integer sorting algorithm.                                                                     ——from wikipedia</p><hr><h3 id="2-排序思路"><a href="#2-排序思路" class="headerlink" title="2.排序思路"></a>2.排序思路</h3><p>​        通过数组实现，将原数组中整数的值，作为索引，在另一个数组上对应的索引累加。也就是说，不通过比较，而是索引下标确定值的位置。然后遍历目标数组，依次输出就是排序后的结果。一般用于比较小的正整数，太大会造成目标数组空间的浪费。keys 可以理解为 index的键， 既然将值作为索引，那负数是不支持的。但是为了对负数也能够排序，在初始化数组空间的时候，可以通过加上一个固定的值（max-min+1），来实现对负数的取正。 </p><h3 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h3><p>​        下面以力扣的912.排序数组为例：</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">Input:<br><span class="hljs-string">[1, 3, 2, 8, 5, 1, 5, 1, 2, 7]</span><br>Output:<br><span class="hljs-string">[1, 1, 1, 2, 2, 3, 5, 5, 7, 8]</span><br></code></pre></td></tr></table></figure><p>首先需要初始化三个变量，max用于计算数据最大值，dp初始化为空数组用于输出，ans用于构建计数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        这个时候就算是写完了，但是拿去测试的时候你会发现报错了。为什么呢？题目中给出的数据范围是：[-50000,50000]，这时候你看完了前面的内容可能会想了，计数排序无法适用于负数的原因就是将值作为索引，那么索引一定不能是负的。出错的原因就在这！前面也提到了有解决的办法，其实很简单。只需要稍加修改.</p><p>​        添加变量min用于计算数据中的最小值，在数组初始化的时候，空间大小初始化为max-min+1，也就是间接的将负数对应的索引”取正“。这里在后面的几个循环中需要注意循环截止的条件！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> max=<span class="hljs-built_in">Math</span>.max(...nums)<br>    <span class="hljs-keyword">let</span> min=<span class="hljs-built_in">Math</span>.min(...nums)<br>    <span class="hljs-keyword">let</span> dp =[]<br>    <span class="hljs-keyword">let</span> ans=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max-min+<span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d <span class="hljs-keyword">of</span> nums)&#123;<br>        ans[d-min]++<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= max-min+<span class="hljs-number">1</span>; k++)&#123;<br>        <span class="hljs-keyword">while</span>(ans[k]-- &gt; <span class="hljs-number">0</span>)&#123;<br>            dp.push(k+min);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;;<br></code></pre></td></tr></table></figure><p>​        写到此，计数排序的代码已经完成了，有兴趣的可以试试原地排序。</p><p>​        特别需要提到的，在翻阅了很多资料中，并没有给出过Js的计数排序模板，Js的数组也不是实际意义上的数组，而是对象，还有很多方法可以用来优化以上代码，但思路始终是这个思路，这里暂且不提。</p><blockquote><p>全文代码通过JavaScript实现</p><p>参考资料：</p><p>[1]:<a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p>[2]:<a href="https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/">https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5reklv/</a></p><p>[3]:<a href="https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c">https://medium.com/javascript-algorithms/javascript-algorithms-counting-sort-c94a5fd70c9c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>排序</tag>
      
      <tag>计数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
